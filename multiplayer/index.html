<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Wheel Spin — Multiplayer</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
<script src="sounds/sounds.js"></script>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #1a1a2e;
    --surface: #16213e;
    --surface2: #0f3460;
    --text: #e4e4e4;
    --text-muted: #8892a4;
    --accent: #e94560;
    --accent-hover: #ff6b81;
  }

  body {
    font-family: 'Nunito', 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  header {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px 24px;
    background: var(--surface);
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  header h1 {
    font-size: 1.3rem;
    font-weight: 700;
    letter-spacing: 1px;
    background: linear-gradient(135deg, #e94560, #f5a623, #50e3c2, #4a90d9);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .app {
    display: flex;
    flex: 1;
    overflow: hidden;
  }

  /* ── Wheel Panel ── */
  .wheel-panel {
    flex: 1;
    display: grid;
    grid-template-columns: 1fr;
    align-items: center;
    justify-items: center;
    min-width: 0;
    gap: 8px;
    padding: 8px;
    overflow: hidden;
  }
  .wheel-panel.cols-2 { grid-template-columns: 1fr 1fr; }
  .wheel-panel.cols-3 { grid-template-columns: 1fr 1fr 1fr; }

  .wheel-cell {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
  }
  .wheel-cell-title {
    text-align: center;
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-bottom: 4px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
    flex-shrink: 0;
  }
  .wheel-cell-inner {
    position: relative;
  }

  .wheel-canvas {
    width: 100%;
    height: 100%;
    cursor: pointer;
    filter: drop-shadow(0 0 30px rgba(233,69,96,0.15));
    transition: filter 0.3s;
  }
  .wheel-canvas:hover { filter: drop-shadow(0 0 40px rgba(233,69,96,0.3)); }

  .pointer {
    position: absolute;
    top: -18px;
    left: 50%;
    transform: translateX(-50%);
    width: 0; height: 0;
    border-left: 18px solid transparent;
    border-right: 18px solid transparent;
    border-top: 38px solid var(--accent);
    filter: drop-shadow(0 4px 8px rgba(0,0,0,0.4));
    z-index: 10;
    transition: transform 0.05s;
  }
  .pointer.tick { transform: translateX(-50%) rotate(5deg); }

  .center-btn {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 170px; height: 170px;
    border-radius: 50%;
    background: var(--accent);
    color: #fff;
    font-weight: 800;
    font-size: 1.5rem;
    letter-spacing: 2px;
    border: 7px solid rgba(255,255,255,0.2);
    cursor: pointer;
    z-index: 10;
    transition: background 0.2s, transform 0.2s;
    text-transform: uppercase;
  }
  .center-btn:hover { background: var(--accent-hover); transform: translate(-50%, -50%) scale(1.08); }
  .center-btn:active { transform: translate(-50%, -50%) scale(0.96); }
  .center-btn:disabled { opacity: 0.6; cursor: not-allowed; transform: translate(-50%, -50%); }

  /* ── Wheel Toast (inline winner overlay) ── */
  .wheel-toast {
    position: absolute;
    bottom: 12%;
    left: 50%;
    transform: translateX(-50%) scale(0.8);
    background: rgba(22,33,62,0.92);
    border: 1px solid rgba(233,69,96,0.4);
    border-radius: 14px;
    padding: 14px 28px;
    text-align: center;
    z-index: 20;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.35s, transform 0.35s;
    backdrop-filter: blur(6px);
    max-width: 80%;
  }
  .wheel-toast.show {
    opacity: 1;
    pointer-events: auto;
    transform: translateX(-50%) scale(1);
    cursor: pointer;
  }
  .wheel-toast-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-muted);
    margin-bottom: 4px;
  }
  .wheel-toast-name {
    font-size: 1.3rem;
    font-weight: 800;
    background: linear-gradient(135deg, #e94560, #f5a623);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    word-break: break-word;
  }

  /* Sub-wheel cells (dynamically added) */
  .wheel-cell.sub-cell .wheel-canvas,
  .wheel-cell.sub-cell .pointer,
  .wheel-cell.sub-cell .center-btn { pointer-events: none; }
  .wheel-cell.sub-cell {
    animation: cellAppear 0.4s ease-out;
  }
  @keyframes cellAppear {
    from { opacity: 0; transform: scale(0.8); }
    to { opacity: 1; transform: scale(1); }
  }

  /* ── Wheel Selector ── */
  .wheel-selector {
    position: fixed;
    top: 60px;
    right: 20px;
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 8px 12px;
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 10px;
    z-index: 50;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .wheel-selector select {
    flex: 1;
    min-width: 0;
    padding: 6px 8px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    font-family: inherit;
    font-size: 0.82rem;
    outline: none;
  }
  .wheel-selector button {
    background: transparent;
    border: 1px solid rgba(255,255,255,0.1);
    color: var(--text);
    border-radius: 6px;
    padding: 4px 8px;
    cursor: pointer;
    font-size: 0.85rem;
    line-height: 1;
  }
  .wheel-selector button:hover { border-color: var(--accent); color: var(--accent); }

  /* Stock Market */
  .stock-row { display:flex;flex-direction:column;gap:4px;padding:8px 10px;margin-bottom:6px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.06);border-radius:8px; }
  .stock-header { display:flex;align-items:center;gap:8px; }
  .stock-name { flex:1;font-weight:600;font-size:0.85rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; }
  .stock-price { font-weight:700;font-size:0.9rem;white-space:nowrap; }
  .stock-change { font-size:0.75rem;font-weight:700;white-space:nowrap;padding:1px 6px;border-radius:4px; }
  .stock-change.up { color:#47B04B;background:rgba(71,176,75,0.15); }
  .stock-change.down { color:#E74856;background:rgba(231,72,86,0.15); }
  .stock-change.flat { color:var(--text-muted); }
  .stock-trade { display:flex;gap:6px;align-items:center; }
  .stock-trade input { width:50px;padding:4px 6px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);background:var(--bg);color:var(--text);font-family:inherit;font-size:0.8rem;text-align:center; }
  .stock-trade button { padding:4px 10px;border-radius:6px;border:none;font-family:inherit;font-weight:700;font-size:0.75rem;cursor:pointer; }
  .stock-buy { background:#47B04B;color:#fff; } .stock-buy:hover { background:#3a9a3f; }
  .stock-sell { background:#E74856;color:#fff; } .stock-sell:hover { background:#c5303e; }
  .stock-holdings { font-size:0.72rem;color:var(--text-muted); }
  .stock-sparkline { width:60px;height:20px;flex-shrink:0; }
  .stock-portfolio-value { font-size:0.7rem;color:#F5A623;font-weight:600; }
  .stock-row.selected { background:rgba(233,69,96,0.15);border-color:var(--accent); }
  .stock-row { cursor:pointer;transition:background 0.2s,border-color 0.2s; }
  .stock-row:hover { background:rgba(255,255,255,0.05); }
  #stockDetailTrade input[type="number"] { padding:6px 8px;border-radius:6px;border:1px solid rgba(255,255,255,0.1);background:var(--bg);color:var(--text);font-family:inherit;font-size:0.85rem;text-align:center; }
  #stockDetailTrade input[type="radio"] { accent-color:var(--accent); }
  #stockDetailTrade button { padding:8px 16px;border-radius:8px;border:none;font-family:inherit;font-weight:700;font-size:0.85rem;cursor:pointer;transition:background 0.2s; }

  /* Order tabs and panels */
  .order-tab { padding:6px 12px;border:none;background:var(--bg);color:var(--text-muted);border-radius:6px;font-family:inherit;font-size:0.8rem;cursor:pointer;transition:all 0.2s; }
  .order-tab:hover { color:var(--text); }
  .order-tab.active { background:var(--accent);color:#fff; }
  .order-item { display:flex;align-items:center;gap:8px;padding:8px 10px;background:var(--bg);border-radius:6px;margin-bottom:6px;font-size:0.8rem; }
  .order-item .order-type { font-weight:700;width:40px; }
  .order-item .order-type.buy { color:#47B04B; }
  .order-item .order-type.sell { color:#E74856; }
  .order-item .order-stock { flex:1;color:var(--text); }
  .order-item .order-shares { color:var(--text-muted); }
  .order-item .order-price { color:#F5A623;min-width:60px;text-align:right; }
  .order-item .order-status { font-size:0.7rem;padding:2px 6px;border-radius:4px; }
  .order-item .order-status.pending { background:rgba(245,166,35,0.2);color:#F5A623; }
  .order-item .order-status.partial { background:rgba(71,176,75,0.2);color:#47B04B; }
  .order-item .order-status.filled { background:rgba(71,176,75,0.3);color:#47B04B; }
  .order-item .order-status.cancelled { background:rgba(231,72,86,0.2);color:#E74856; }
  .order-item .order-cancel { background:#E74856;color:#fff;border:none;padding:4px 8px;border-radius:4px;font-size:0.7rem;cursor:pointer; }
  .order-item .order-cancel:hover { background:#c5303e; }
  .order-empty { color:var(--text-muted);font-size:0.8rem;padding:12px;text-align:center; }

  /* Position items */
  .position-item:hover { background:rgba(255,255,255,0.08) !important; }
  #stockDetailChart { cursor:crosshair; }

  /* Menu buttons bar */
  .menu-buttons {
    position: fixed;
    bottom: 20px;
    right: 20px;
    display: flex;
    gap: 10px;
    z-index: 100;
  }
  .menu-btn {
    padding: 12px 20px;
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 12px;
    color: var(--text);
    font-family: inherit;
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  }
  .menu-btn:hover {
    background: var(--surface2);
    transform: translateY(-2px);
  }
  .menu-btn.active {
    background: var(--accent);
    border-color: var(--accent);
  }

  /* Popup overlay */
  .popup-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.85);
    z-index: 200;
    display: none;
  }
  .popup-overlay.show {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Popup container */
  .popup {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    max-width: 90vw;
    max-height: 85vh;
    width: 550px;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
  }
  .popup.wide { width: 1100px; max-height: 90vh; }

  .popup-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px 20px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
    flex-shrink: 0;
  }
  .popup-title {
    flex: 1;
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--text);
  }
  .popup-close {
    background: none;
    border: none;
    color: var(--text-muted);
    font-size: 1.5rem;
    cursor: pointer;
    padding: 4px 8px;
    line-height: 1;
    transition: color 0.2s;
  }
  .popup-close:hover { color: var(--accent); }

  .popup-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
  }
  .popup-body::-webkit-scrollbar { width: 6px; }
  .popup-body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }

  /* Stock detail panel */
  .stock-detail-header {
    margin-bottom: 16px;
    padding-bottom: 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  .stock-detail-header h3 {
    font-size: 1.3rem;
    font-weight: 700;
    margin-bottom: 8px;
  }
  .stock-detail-chart {
    background: rgba(0,0,0,0.2);
    border-radius: 8px;
    margin-bottom: 16px;
  }
  .stock-detail-trade {
    display: flex;
    gap: 8px;
    align-items: center;
    flex-wrap: wrap;
  }
  .stock-detail-trade input {
    width: 70px;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg);
    color: var(--text);
    font-family: inherit;
    font-size: 0.9rem;
    text-align: center;
  }
  .stock-detail-trade button {
    padding: 8px 16px;
    border-radius: 8px;
    border: none;
    font-family: inherit;
    font-weight: 700;
    font-size: 0.85rem;
    cursor: pointer;
  }

  /* Entries tab */
  .sidebar-header {
    padding: 12px 16px 8px;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .sidebar-header h2 {
    font-size: 0.85rem;
    font-weight: 600;
    color: var(--text-muted);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  .entry-count {
    font-size: 0.75rem;
    color: var(--text-muted);
    background: var(--surface2);
    padding: 2px 8px;
    border-radius: 20px;
  }

  textarea#namesInput {
    flex: 1;
    background: transparent;
    border: none;
    outline: none;
    color: var(--text);
    font-family: inherit;
    font-size: 0.9rem;
    padding: 12px 16px;
    resize: none;
    line-height: 1.7;
  }
  textarea#namesInput::placeholder { color: var(--text-muted); }

  .sidebar-actions {
    padding: 10px 16px;
    display: flex;
    gap: 8px;
    border-top: 1px solid rgba(255,255,255,0.06);
  }
  .sidebar-actions button {
    flex: 1;
    padding: 8px 0;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-family: inherit;
    font-weight: 600;
    font-size: 0.78rem;
    transition: background 0.2s, opacity 0.2s;
  }
  .btn-shuffle { background: var(--surface2); color: var(--text); }
  .btn-shuffle:hover { opacity: 0.85; }
  .btn-reset { background: rgba(233,69,96,0.15); color: var(--accent); }
  .btn-reset:hover { background: rgba(233,69,96,0.25); }

  /* Configure tab */
  .config-panel {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
  }
  .config-panel::-webkit-scrollbar { width: 6px; }
  .config-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }

  .config-section {
    margin-bottom: 20px;
  }
  .config-section-title {
    font-size: 0.75rem;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--text-muted);
    margin-bottom: 10px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }

  .config-entry {
    display: flex;
    flex-direction: column;
    gap: 4px;
    padding: 8px;
    margin-bottom: 6px;
    background: rgba(255,255,255,0.02);
    border: 1px solid rgba(255,255,255,0.04);
    border-radius: 8px;
  }
  .config-entry-name {
    font-size: 0.85rem;
    font-weight: 600;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    min-width: 0;
  }
  .config-entry-row {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .config-entry-row-label {
    font-size: 0.62rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    width: 46px;
    flex-shrink: 0;
  }
  .config-entry select {
    flex: 1;
    min-width: 0;
    padding: 4px 6px;
    background: var(--surface2);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 6px;
    font-family: inherit;
    font-size: 0.75rem;
    outline: none;
    cursor: pointer;
  }
  .config-entry select:focus { border-color: var(--accent); }
  .vol-slider {
    width: 60px;
    flex-shrink: 0;
    accent-color: var(--accent);
    cursor: pointer;
  }
  .vol-label {
    font-size: 0.65rem;
    color: var(--text-muted);
    width: 28px;
    text-align: right;
    flex-shrink: 0;
  }
  .fs-slider {
    flex: 1;
    min-width: 60px;
    accent-color: #50e3c2;
    cursor: pointer;
  }
  .fs-label {
    font-size: 0.65rem;
    color: var(--text-muted);
    width: 28px;
    text-align: right;
    flex-shrink: 0;
  }

  .preview-btn {
    background: transparent;
    border: none;
    color: var(--text-muted);
    cursor: pointer;
    font-size: 0.85rem;
    padding: 2px 4px;
    border-radius: 4px;
  }
  .preview-btn:hover { color: var(--accent); }

  /* ── Winner Modal ── */
  .modal-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  .modal-overlay.show { display: flex; }

  .modal {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    padding: 48px 56px;
    text-align: center;
    animation: modalPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    max-width: 420px;
  }
  @keyframes modalPop {
    from { opacity: 0; transform: scale(0.7) translateY(20px); }
    to   { opacity: 1; transform: scale(1) translateY(0); }
  }
  .modal .winner-label {
    font-size: 0.85rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--text-muted);
    margin-bottom: 12px;
  }
  .modal .winner-name {
    font-size: 2.2rem;
    font-weight: 800;
    margin-bottom: 28px;
    background: linear-gradient(135deg, #e94560, #f5a623);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    word-break: break-word;
  }
  .modal-buttons { display: flex; gap: 10px; justify-content: center; }
  .modal-buttons button {
    padding: 10px 24px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-weight: 600;
    font-size: 0.88rem;
    transition: background 0.2s;
  }
  .btn-close-modal { background: var(--surface2); color: var(--text); }
  .btn-close-modal:hover { background: #1a4a8a; }

  /* ── Action Modal (Add/Remove Entry) ── */
  .action-overlay {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    z-index: 100;
    align-items: center;
    justify-content: center;
  }
  .action-overlay.show { display: flex; }
  .action-modal {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 20px;
    padding: 36px 44px;
    text-align: center;
    animation: modalPop 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    max-width: 420px;
    min-width: 300px;
  }
  .action-modal h3 {
    font-size: 1.1rem;
    font-weight: 700;
    margin-bottom: 8px;
    color: var(--text);
  }
  .action-modal p {
    font-size: 0.82rem;
    color: var(--text-muted);
    margin-bottom: 16px;
  }
  .action-modal input[type="text"],
  .action-modal select {
    width: 100%;
    padding: 10px 12px;
    background: var(--bg);
    color: var(--text);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    font-family: inherit;
    font-size: 0.9rem;
    margin-bottom: 16px;
    outline: none;
  }
  .action-modal input[type="text"]:focus,
  .action-modal select:focus { border-color: var(--accent); }
  .action-modal .action-buttons { display: flex; gap: 10px; justify-content: center; }
  .action-modal .action-buttons button {
    padding: 10px 24px;
    border-radius: 10px;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-weight: 600;
    font-size: 0.88rem;
    transition: background 0.2s;
  }
  .action-modal .btn-action-confirm { background: var(--accent); color: #fff; }
  .action-modal .btn-action-confirm:hover { background: var(--accent-hover); }
  .action-modal .btn-action-cancel { background: var(--surface2); color: var(--text); }
  .action-modal .btn-action-cancel:hover { background: #1a4a8a; }

  /* ── Confetti ── */
  .confetti-container {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 200;
    overflow: hidden;
  }
  .confetti-piece {
    position: absolute;
    width: 8px;
    height: 14px;
    will-change: transform;
    animation: confettiFall linear forwards;
  }
  @keyframes confettiFall {
    0%   { opacity: 1; }
    90%  { opacity: 1; }
    100% { opacity: 0; }
  }

  /* ── Connection UI ── */
  .connection-overlay {
    position: fixed; inset: 0; z-index: 1000;
    background: var(--bg);
    display: flex; align-items: center; justify-content: center;
    transition: opacity 0.3s;
  }
  .connection-overlay.hidden { opacity: 0; pointer-events: none; }
  .connection-box {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.08);
    border-radius: 16px;
    padding: 32px 40px;
    width: 400px;
    max-width: 90vw;
  }
  .connection-box h2 {
    text-align: center; margin-bottom: 20px;
    background: linear-gradient(135deg, #e94560, #f5a623);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
  }
  .conn-tabs { display: flex; gap: 0; margin-bottom: 16px; border-radius: 8px; overflow: hidden; }
  .conn-tabs button {
    flex: 1; padding: 10px; border: none; cursor: pointer;
    background: var(--surface2); color: var(--text-muted);
    font-family: inherit; font-weight: 600; font-size: 0.9rem;
    transition: background 0.2s, color 0.2s;
  }
  .conn-tabs button.active { background: var(--accent); color: #fff; }
  .conn-form { display: none; flex-direction: column; gap: 12px; }
  .conn-form.active { display: flex; }
  .conn-form input {
    padding: 10px 14px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg); color: var(--text); font-family: inherit; font-size: 0.95rem;
    outline: none;
  }
  .conn-form input:focus { border-color: var(--accent); }
  .conn-form button.conn-submit {
    padding: 12px; border-radius: 8px; border: none;
    background: var(--accent); color: #fff; font-family: inherit;
    font-weight: 700; font-size: 1rem; cursor: pointer;
    transition: background 0.2s;
  }
  .conn-form button.conn-submit:hover { background: var(--accent-hover); }
  .conn-form button.conn-submit:disabled { opacity: 0.5; cursor: not-allowed; }
  .conn-error { color: #e94560; font-size: 0.85rem; text-align: center; min-height: 1.2em; }

  /* ── Status bar ── */
  .status-bar {
    display: none; align-items: center; gap: 10px;
    padding: 6px 16px;
    background: var(--surface);
    border-bottom: 1px solid rgba(255,255,255,0.06);
    font-size: 0.8rem;
  }
  .status-bar.visible { display: flex; }
  .status-dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: #47B04B; flex-shrink: 0;
  }
  .status-dot.disconnected { background: #E74856; }
  .status-dot.connecting { background: #F5A623; animation: pulse 1s infinite; }
  @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.4; } }
  .status-bar .status-text { flex: 1; color: var(--text-muted); }
  .status-bar .status-name { font-weight: 700; color: var(--text); }
  .status-bar .host-badge {
    background: var(--accent); color: #fff; padding: 1px 8px;
    border-radius: 4px; font-size: 0.7rem; font-weight: 700; letter-spacing: 1px;
  }
  .status-bar button {
    padding: 4px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15);
    background: transparent; color: var(--text-muted); cursor: pointer;
    font-family: inherit; font-size: 0.75rem;
  }
  .status-bar button:hover { background: rgba(255,255,255,0.05); }

  /* ── Spin initiator overlay ── */
  .spin-initiator {
    position: absolute; top: 12px; left: 50%; transform: translateX(-50%);
    background: rgba(22,33,62,0.9); color: var(--text);
    padding: 6px 18px; border-radius: 20px;
    font-size: 0.85rem; font-weight: 600; z-index: 20;
    opacity: 0; transition: opacity 0.3s; pointer-events: none;
    white-space: nowrap;
  }
  .spin-initiator.show { opacity: 1; }

  /* ── Scoreboard (inside left panel) ── */
  .scoreboard {
    display: none;
  }
  .scoreboard.visible { display: block; }
  .scoreboard-title {
    font-size: 0.7rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1px; color: var(--text-muted); margin-bottom: 6px;
  }
  .sb-player {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 0; font-size: 0.85rem;
  }
  .sb-player.disconnected { opacity: 0.35; }
  .sb-avatar {
    width: 24px; height: 24px; border-radius: 50%;
    background: var(--accent); color: #fff;
    display: flex; align-items: center; justify-content: center;
    font-weight: 800; font-size: 0.65rem; flex-shrink: 0;
  }
  .sb-name { flex: 1; font-weight: 600; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .sb-badge {
    padding: 1px 5px; border-radius: 3px;
    font-size: 0.55rem; font-weight: 700; letter-spacing: 0.5px;
  }
  .sb-badge.host { background: var(--accent); color: #fff; }
  .sb-badge.you { background: var(--surface2); color: var(--text-muted); }
  .sb-money { color: #47B04B; font-weight: 700; font-size: 0.85rem; white-space: nowrap; }

  /* ── Ready-up / Betting overlay ── */
  .ready-overlay {
    position: fixed; inset: 0; z-index: 200;
    background: rgba(0,0,0,0.7);
    display: none; align-items: center; justify-content: center;
    backdrop-filter: blur(3px);
  }
  .ready-overlay.show { display: flex; }
  .ready-box {
    background: var(--surface);
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 16px;
    padding: 28px 36px;
    width: 460px; max-width: 92vw;
    text-align: center;
  }
  .ready-box h2 {
    font-size: 1.2rem; margin-bottom: 6px; color: var(--text);
  }
  .ready-countdown {
    font-size: 2.5rem; font-weight: 800;
    color: var(--accent); margin: 10px 0;
    font-variant-numeric: tabular-nums;
  }
  .ready-players {
    display: flex; flex-wrap: wrap; gap: 8px; justify-content: center;
    margin: 12px 0;
  }
  .ready-chip {
    padding: 4px 12px; border-radius: 20px;
    font-size: 0.8rem; font-weight: 600;
    background: var(--surface2); color: var(--text-muted);
    transition: background 0.3s, color 0.3s;
  }
  .ready-chip.is-ready { background: #47B04B; color: #fff; }

  .bet-section {
    margin-top: 16px; padding-top: 14px;
    border-top: 1px solid rgba(255,255,255,0.08);
    text-align: left;
  }
  .bet-section label {
    display: block; font-size: 0.8rem; color: var(--text-muted);
    margin-bottom: 4px; font-weight: 600;
  }
  .bet-row {
    display: flex; gap: 8px; align-items: center; margin-bottom: 10px;
  }
  .bet-row select, .bet-row input {
    flex: 1; padding: 8px 10px; border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg); color: var(--text);
    font-family: inherit; font-size: 0.9rem;
  }
  .bet-row input[type="number"] { max-width: 100px; }
  .bet-confirm {
    display: block; width: 100%; padding: 8px;
    border-radius: 8px; border: none;
    background: #47B04B; color: #fff;
    font-family: inherit; font-weight: 700; font-size: 0.9rem;
    cursor: pointer; margin-bottom: 8px;
    transition: background 0.2s;
  }
  .bet-confirm:hover { background: #3a9a3f; }
  .bet-confirm:disabled { opacity: 0.5; cursor: not-allowed; }
  .bet-status {
    font-size: 0.8rem; color: var(--text-muted);
    text-align: center; min-height: 1.2em;
  }

  .ready-btn {
    padding: 12px 36px; border-radius: 10px; border: none;
    background: var(--accent); color: #fff;
    font-family: inherit; font-weight: 700; font-size: 1rem;
    cursor: pointer; margin-top: 10px;
    transition: background 0.2s, transform 0.1s;
  }
  .ready-btn:hover { background: var(--accent-hover); }
  .ready-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
  .ready-btn.is-ready { background: #47B04B; }

  /* ── Bet results toast ── */
  .bet-results {
    position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
    z-index: 100; display: flex; flex-direction: column; gap: 6px;
    pointer-events: none;
  }
  .bet-result-item {
    padding: 8px 20px; border-radius: 10px;
    font-size: 0.9rem; font-weight: 700;
    text-align: center; animation: betResultPop 0.3s ease-out;
    white-space: nowrap;
  }
  .bet-result-item.won { background: #47B04B; color: #fff; }
  .bet-result-item.lost { background: #E74856; color: #fff; }
  @keyframes betResultPop {
    from { transform: translateY(20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
  }

  /* ── Shop tab ── */
  .shop-items { display: flex; flex-direction: column; gap: 6px; padding: 4px 0; }
  .shop-item-btn {
    display: flex; align-items: center; gap: 10px;
    padding: 10px 14px; border-radius: 10px;
    border: 1px solid rgba(255,255,255,0.08);
    background: var(--surface2); color: var(--text);
    font-family: inherit; font-size: 0.9rem; font-weight: 600;
    cursor: pointer; transition: background 0.2s, border-color 0.2s;
    text-align: left; width: 100%;
  }
  .shop-item-btn:hover { background: rgba(255,255,255,0.08); border-color: var(--accent); }
  .shop-item-btn:disabled { opacity: 0.4; cursor: not-allowed; }
  .shop-item-btn .shop-item-name { flex: 1; }
  .shop-item-btn .shop-item-cost {
    color: #47B04B; font-weight: 700; white-space: nowrap;
  }
  .shop-item-btn .shop-item-action {
    font-size: 0.7rem; color: var(--text-muted); font-weight: 400;
  }
  .shop-empty {
    text-align: center; padding: 24px 12px;
    color: var(--text-muted); font-size: 0.85rem;
  }

  /* ── Shop edit mode (host) ── */
  .shop-edit-toggle {
    padding: 6px 14px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15);
    background: transparent; color: var(--text-muted); cursor: pointer;
    font-family: inherit; font-size: 0.75rem; font-weight: 600;
    transition: background 0.2s;
  }
  .shop-edit-toggle:hover { background: rgba(255,255,255,0.05); }
  .shop-edit-toggle.active { background: var(--accent); color: #fff; border-color: var(--accent); }
  .shop-edit-form {
    display: none; flex-direction: column; gap: 8px;
    padding: 12px; margin-top: 8px;
    border: 1px dashed rgba(255,255,255,0.15);
    border-radius: 10px; background: rgba(0,0,0,0.15);
  }
  .shop-edit-form.visible { display: flex; }
  .shop-edit-form input, .shop-edit-form select {
    padding: 8px 10px; border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg); color: var(--text);
    font-family: inherit; font-size: 0.85rem;
  }
  .shop-edit-form button {
    padding: 8px; border-radius: 6px; border: none;
    background: #47B04B; color: #fff;
    font-family: inherit; font-weight: 700; font-size: 0.85rem;
    cursor: pointer;
  }
  .shop-edit-form button:hover { background: #3a9a3f; }
  .shop-item-edit-row {
    display: flex; align-items: center; gap: 6px;
    padding: 6px 10px; border-radius: 8px;
    background: rgba(255,255,255,0.03);
  }
  .shop-item-edit-row .shop-item-name { flex: 1; font-weight: 600; font-size: 0.85rem; }
  .shop-item-edit-row .shop-item-cost { color: #47B04B; font-weight: 700; font-size: 0.85rem; }
  .shop-item-del {
    padding: 2px 8px; border-radius: 4px; border: none;
    background: #E74856; color: #fff; cursor: pointer;
    font-size: 0.7rem; font-weight: 700;
  }

  /* ── Left Panel (inventory + boost) ── */
  .left-panel {
    display: none;
    flex-direction: column;
    width: 220px;
    min-width: 180px;
    background: var(--surface);
    border-right: 1px solid rgba(255,255,255,0.06);
    overflow-y: auto;
    overflow-x: hidden;
  }
  .left-panel.visible { display: flex; }
  .left-panel::-webkit-scrollbar { width: 5px; }
  .left-panel::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }

  .lp-section {
    padding: 10px 12px;
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  .lp-section-title {
    font-size: 0.65rem; font-weight: 700; text-transform: uppercase;
    letter-spacing: 1px; color: var(--text-muted); margin-bottom: 8px;
  }

  /* Inventory items in left panel */
  .inv-slot {
    display: flex; align-items: center; gap: 8px;
    padding: 7px 10px; border-radius: 8px;
    border: 1px solid rgba(255,255,255,0.06);
    background: rgba(255,255,255,0.02);
    cursor: pointer; margin-bottom: 5px;
    transition: border-color 0.2s, background 0.2s;
  }
  .inv-slot:hover { border-color: var(--accent); background: rgba(233,69,96,0.08); }
  .inv-slot.disabled { opacity: 0.35; cursor: not-allowed; pointer-events: none; }
  .inv-slot .inv-icon { font-size: 1.1rem; flex-shrink: 0; }
  .inv-slot .inv-info { flex: 1; min-width: 0; }
  .inv-slot .inv-name {
    font-size: 0.78rem; font-weight: 600; color: var(--text);
    white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
  }
  .inv-slot .inv-type {
    font-size: 0.6rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 0.5px;
  }
  .inv-slot .inv-key {
    font-size: 0.6rem; color: var(--text-muted); font-weight: 700;
    background: rgba(255,255,255,0.06); padding: 1px 5px; border-radius: 3px;
  }
  .inv-empty {
    font-size: 0.75rem; color: var(--text-muted); text-align: center; padding: 10px 0;
  }

  /* Boost section in left panel */
  .lp-boost-row { display: flex; gap: 6px; margin-bottom: 6px; }
  .lp-boost-row select, .lp-boost-row input {
    flex: 1; padding: 6px 8px; border-radius: 6px;
    border: 1px solid rgba(255,255,255,0.1);
    background: var(--bg); color: var(--text);
    font-family: inherit; font-size: 0.8rem;
  }
  .lp-boost-impact {
    font-size: 0.75rem; text-align: center; margin: 4px 0;
  }
  .lp-boost-btn {
    display: block; width: 100%; padding: 7px;
    border-radius: 7px; border: none;
    background: #47B04B; color: #fff;
    font-family: inherit; font-weight: 700; font-size: 0.8rem;
    cursor: pointer; transition: background 0.2s;
  }
  .lp-boost-btn:hover { background: #3a9a3f; }
  .lp-boost-btn:disabled { opacity: 0.5; cursor: not-allowed; }
  .lp-boost-status {
    font-size: 0.75rem; color: var(--text-muted); text-align: center; min-height: 1em; margin-top: 4px;
  }

  /* ── Bet tooltip on wheel ── */
  .bet-tooltip {
    position: absolute; pointer-events: none;
    background: rgba(20,20,40,0.92); color: #fff; padding: 6px 10px;
    border-radius: 6px; font-size: 0.75rem; white-space: nowrap;
    z-index: 100; transform: translate(-50%, -100%); margin-top: -8px;
    border: 1px solid rgba(255,255,255,0.15);
    box-shadow: 0 4px 12px rgba(0,0,0,0.4);
  }
  .bet-tooltip-row { display: flex; align-items: center; gap: 6px; margin: 2px 0; }
  .bet-tooltip-dot { width: 8px; height: 8px; border-radius: 50%; flex-shrink: 0; }
  .wheel-bet-hint {
    position: absolute; bottom: 4px; left: 50%; transform: translateX(-50%);
    font-size: 0.65rem; color: var(--text-muted); opacity: 0.7;
    pointer-events: none; white-space: nowrap;
  }

  /* ── Ready Bar (below status bar) ── */
  .ready-bar {
    display: none; align-items: center; gap: 12px;
    padding: 8px 16px;
    background: var(--surface2);
    border-bottom: 1px solid rgba(255,255,255,0.06);
  }
  .ready-bar.visible { display: flex; }
  .ready-bar-btn {
    padding: 8px 24px; border-radius: 8px; border: none;
    background: var(--accent); color: #fff;
    font-family: inherit; font-weight: 700; font-size: 0.9rem;
    cursor: pointer; transition: background 0.2s, transform 0.1s;
    flex-shrink: 0;
  }
  .ready-bar-btn:hover { background: var(--accent-hover); }
  .ready-bar-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
  .ready-bar-btn.is-ready { background: #47B04B; }
  .ready-bar-countdown {
    font-size: 1.3rem; font-weight: 800; color: var(--accent);
    font-variant-numeric: tabular-nums; min-width: 30px;
  }
  .ready-bar-players {
    display: flex; flex-wrap: wrap; gap: 6px; flex: 1;
  }
  .ready-bar-chip {
    padding: 3px 10px; border-radius: 14px;
    font-size: 0.72rem; font-weight: 600;
    background: var(--surface); color: var(--text-muted);
    transition: background 0.3s, color 0.3s;
  }
  .ready-bar-chip.is-ready { background: #47B04B; color: #fff; }

  /* ══════════════════════════════════════════════════════════════════════════
     RESPONSIVE STYLES
     ══════════════════════════════════════════════════════════════════════════ */

  /* Large screens - default wheel size constraint */
  .wheel-cell-inner {
    max-width: min(500px, 70vh);
    max-height: min(500px, 70vh);
  }

  /* Medium screens (tablets, smaller monitors) */
  @media (max-width: 1200px) {
    .popup.wide {
      width: 95vw;
      max-width: 900px;
    }
    #stockDetailChart {
      width: 100% !important;
      max-width: 400px;
      height: auto !important;
      max-height: 220px;
    }
    #positionsPanel {
      flex: 0 0 220px !important;
    }
  }

  /* Smaller screens (small tablets, large phones) */
  @media (max-width: 900px) {
    .wheel-cell-inner {
      max-width: min(400px, 60vh);
      max-height: min(400px, 60vh);
    }
    .center-btn {
      width: 130px;
      height: 130px;
      font-size: 1.2rem;
      border-width: 5px;
    }
    .pointer {
      border-left: 14px solid transparent;
      border-right: 14px solid transparent;
      border-top: 30px solid var(--accent);
      top: -14px;
    }
    .popup.wide {
      width: 98vw;
      max-height: 95vh;
    }
    /* Stack market panels vertically */
    .popup.wide .popup-body {
      flex-direction: column !important;
    }
    #stockList {
      max-height: 35vh;
      overflow-y: auto;
    }
    #stockDetail {
      border-left: none !important;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-left: 0 !important;
      padding-top: 12px;
    }
    #positionsPanel {
      flex: 0 0 auto !important;
      border-left: none !important;
      border-top: 1px solid rgba(255,255,255,0.1);
      padding-left: 0 !important;
      padding-top: 12px;
      max-height: 30vh !important;
    }
    #stockDetailChart {
      max-width: 100%;
      max-height: 180px;
    }
    .menu-buttons {
      gap: 6px;
    }
    .menu-btn {
      padding: 10px 14px;
      font-size: 0.8rem;
    }
    .left-panel {
      width: 180px;
      min-width: 150px;
    }
  }

  /* Mobile screens */
  @media (max-width: 600px) {
    .wheel-cell-inner {
      max-width: min(320px, 55vh);
      max-height: min(320px, 55vh);
    }
    .center-btn {
      width: 100px;
      height: 100px;
      font-size: 1rem;
      border-width: 4px;
    }
    .pointer {
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-top: 26px solid var(--accent);
      top: -12px;
    }
    .popup {
      width: 98vw;
      max-height: 95vh;
      border-radius: 12px;
    }
    .popup.wide {
      width: 98vw;
    }
    .popup-header {
      padding: 12px 14px;
    }
    .popup-body {
      padding: 12px 14px;
    }
    .menu-buttons {
      bottom: 10px;
      right: 10px;
      gap: 4px;
    }
    .menu-btn {
      padding: 8px 10px;
      font-size: 0.75rem;
      border-radius: 8px;
    }
    .wheel-selector {
      top: auto;
      bottom: 70px;
      right: 10px;
      padding: 6px 10px;
    }
    .left-panel {
      display: none !important;
    }
    .status-bar {
      padding: 4px 10px;
      font-size: 0.75rem;
    }
    #stockDetailChart {
      max-height: 150px;
    }
    .stock-row {
      padding: 6px 8px;
    }
    .stock-detail-header h3 {
      font-size: 1.1rem;
    }
  }

  /* Very small screens / low height */
  @media (max-height: 700px) {
    .wheel-cell-inner {
      max-width: min(350px, 50vh);
      max-height: min(350px, 50vh);
    }
    .center-btn {
      width: 110px;
      height: 110px;
      font-size: 1.1rem;
    }
    .popup {
      max-height: 90vh;
    }
  }

  @media (max-height: 500px) {
    .wheel-cell-inner {
      max-width: min(280px, 45vh);
      max-height: min(280px, 45vh);
    }
    .center-btn {
      width: 80px;
      height: 80px;
      font-size: 0.9rem;
      border-width: 3px;
    }
    .pointer {
      border-left: 10px solid transparent;
      border-right: 10px solid transparent;
      border-top: 22px solid var(--accent);
      top: -10px;
    }
  }
</style>
</head>
<body>

<!-- Connection overlay -->
<div class="connection-overlay" id="connectionOverlay">
  <div class="connection-box">
    <h2>WHEEL SPIN — MULTIPLAYER</h2>
    <div class="conn-tabs">
      <button class="active" data-mode="host">Host</button>
      <button data-mode="join">Join</button>
    </div>
    <div class="conn-form active" id="hostForm">
      <input type="text" id="hostNameInput" placeholder="Your name" maxlength="30" value="">
      <input type="number" id="portInput" value="8080" min="1024" max="65535" placeholder="Port">
      <button class="conn-submit" id="startHostBtn">Start Hosting</button>
    </div>
    <div class="conn-form" id="joinForm">
      <input type="text" id="joinNameInput" placeholder="Your name" maxlength="30" value="">
      <input type="text" id="joinAddress" placeholder="IP:Port (e.g. 192.168.1.100:8080)">
      <button class="conn-submit" id="connectBtn">Connect</button>
    </div>
    <div class="conn-error" id="connError"></div>
  </div>
</div>

<header><h1>WHEEL SPIN</h1></header>

<!-- Status bar (visible when connected) -->
<div class="status-bar" id="statusBar">
  <div class="status-dot" id="statusDot"></div>
  <span class="status-name" id="statusName"></span>
  <span class="host-badge" id="statusHostBadge" style="display:none">HOST</span>
  <span class="status-text" id="statusText">Connected</span>
  <button id="disconnectBtn">Disconnect</button>
</div>

<!-- Ready Bar (persistent, below status bar) -->
<div class="ready-bar" id="readyBar">
  <button class="ready-bar-btn" id="readyBarBtn">READY</button>
  <span class="ready-bar-countdown" id="readyBarCountdown"></span>
  <div class="ready-bar-players" id="readyBarPlayers"></div>
</div>

<div class="app" id="app">
  <!-- Left Panel: Scoreboard + Inventory + Boost -->
  <div class="left-panel" id="leftPanel">
    <div class="lp-section" id="lpScoreboard">
      <div class="lp-section-title">Scoreboard</div>
      <div id="scoreboardList"></div>
    </div>
    <div class="lp-section">
      <div class="lp-section-title">Inventory</div>
      <div id="invSlots"></div>
    </div>
  </div>

  <div class="wheel-panel" id="wheelPanel">
    <div class="spin-initiator" id="spinInitiator"></div>
    <div class="wheel-cell" id="mainCell">
      <div class="wheel-cell-inner">
        <div class="pointer" id="mainPointer"></div>
        <canvas class="wheel-canvas" id="mainCanvas"></canvas>
        <button class="center-btn" id="spinBtn">SPIN</button>
        <div class="wheel-toast" id="wheelToast">
          <div class="wheel-toast-label"></div>
          <div class="wheel-toast-name"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Wheel selector (floating) -->
  <div class="wheel-selector" id="wheelSelector">
    <select id="wheelSelect" title="Select wheel"></select>
    <button id="addWheelBtn" title="Add wheel">+</button>
    <button id="renameWheelBtn" title="Rename wheel">&#9998;</button>
    <button id="deleteWheelBtn" title="Delete wheel">&#128465;</button>
  </div>

  <!-- Menu buttons -->
  <div class="menu-buttons" id="menuButtons">
    <button class="menu-btn" data-popup="shop">Shop</button>
    <button class="menu-btn" data-popup="market">Market</button>
    <button class="menu-btn" data-popup="entries">Entries</button>
    <button class="menu-btn" data-popup="configure">Configure</button>
  </div>
</div>

<!-- Shop Popup -->
<div class="popup-overlay" id="popup-shop">
  <div class="popup">
    <div class="popup-header">
      <span class="popup-title">Shop</span>
      <button class="shop-edit-toggle" id="shopEditToggle" style="display:none">Edit</button>
      <button class="popup-close">&times;</button>
    </div>
    <div class="popup-body">
      <div class="shop-items" id="shopItems"></div>
      <div class="shop-edit-form" id="shopEditForm">
        <input type="text" id="shopNewName" placeholder="Item name" maxlength="40">
        <div style="display:flex;gap:6px;">
          <input type="number" id="shopNewCost" placeholder="Cost ($)" min="0" style="flex:1;">
          <select id="shopNewAction" style="flex:1;">
            <option value="add_entry">Add to Wheel</option>
            <option value="remove_entry">Remove from Wheel</option>
            <option value="inventory">Inventory Item</option>
          </select>
        </div>
        <select id="shopNewWheel" title="Target wheel"></select>
        <select id="shopNewItemType" style="display:none;" title="Inventory item type">
          <option value="boost">Wheel Boost (nudge during spin)</option>
        </select>
        <div style="display:flex;gap:6px;align-items:center;">
          <select id="shopNewSound" style="flex:1;" title="Purchase sound effect">
            <option value="">No sound</option>
          </select>
          <button id="shopSoundPreview" style="padding:4px 8px;font-size:0.75rem;" title="Preview sound">&#9654;</button>
        </div>
        <button id="shopAddBtn">Add Item</button>
      </div>
      <!-- Chance Enhancer -->
      <div class="shop-boost-section" id="shopBoostSection" style="padding:10px 0;border-top:1px solid rgba(255,255,255,0.06);margin-top:12px;">
        <div style="font-size:0.75rem;font-weight:700;text-transform:uppercase;letter-spacing:1px;color:var(--text-muted);margin-bottom:10px;">Chance Enhancer</div>
        <div class="lp-boost-row">
          <select id="lpBoostEntry" title="Entry to boost" style="width:100%;"><option value="">Pick entry...</option></select>
        </div>
        <div class="lp-boost-row" style="align-items:center;">
          <span style="font-size:0.7rem;color:var(--text-muted);white-space:nowrap;">$0</span>
          <input type="range" id="lpBoostSlider" min="0" max="100" value="0" style="flex:1;">
          <span id="lpBoostMax" style="font-size:0.7rem;color:var(--text-muted);white-space:nowrap;">$0</span>
        </div>
        <div class="lp-boost-impact">
          <span style="color:var(--text-muted);">Cost: </span><span id="lpBoostCost" style="color:#47B04B;font-weight:700;">$0</span>
          <span style="color:var(--text-muted);margin-left:8px;">Impact: </span><span id="lpBoostImpact" style="color:#F5A623;font-weight:700;">+0%</span>
        </div>
        <button class="lp-boost-btn" id="lpBoostBtn">Apply Boost</button>
        <div class="lp-boost-status" id="lpBoostStatus"></div>
      </div>
    </div>
  </div>
</div>

<!-- Market Popup -->
<div class="popup-overlay" id="popup-market">
  <div class="popup wide">
    <div class="popup-header">
      <span class="popup-title">Stock Market</span>
      <span class="entry-count" id="marketStatus">--</span>
      <button class="popup-close">&times;</button>
    </div>
    <div class="popup-body" style="display:flex;flex-direction:column;gap:16px;">
      <div style="display:flex;gap:16px;flex:1;min-height:0;">
        <div id="stockList" style="flex:0 0 280px;overflow-y:auto;max-height:55vh;"></div>
        <div id="stockDetail" style="flex:1;min-width:0;display:none;">
          <div class="stock-detail-header" id="stockDetailName"></div>
          <div style="position:relative;">
            <canvas class="stock-detail-chart" id="stockDetailChart" width="500" height="280"></canvas>
            <div id="chartTooltip" style="position:absolute;display:none;background:rgba(0,0,0,0.9);border:1px solid rgba(255,255,255,0.2);border-radius:6px;padding:6px 10px;font-size:0.8rem;pointer-events:none;z-index:10;"></div>
          </div>
          <div class="stock-detail-trade" id="stockDetailTrade"></div>
        </div>
        <div id="positionsPanel" style="flex:0 0 260px;border-left:1px solid rgba(255,255,255,0.1);padding-left:16px;overflow-y:auto;max-height:55vh;">
          <h4 style="margin:0 0 12px 0;font-size:0.9rem;color:var(--text-muted);">Your Positions</h4>
          <div id="positionsList"></div>
        </div>
      </div>
      <div id="ordersSection" style="border-top:1px solid rgba(255,255,255,0.1);padding-top:12px;">
        <div style="display:flex;gap:16px;margin-bottom:8px;">
          <button class="order-tab active" data-tab="pending">Pending Orders</button>
          <button class="order-tab" data-tab="history">Order History</button>
        </div>
        <div id="pendingOrdersPanel" class="order-panel" style="max-height:120px;overflow-y:auto;"></div>
        <div id="orderHistoryPanel" class="order-panel" style="max-height:120px;overflow-y:auto;display:none;"></div>
      </div>
    </div>
  </div>
</div>

<!-- Entries Popup -->
<div class="popup-overlay" id="popup-entries">
  <div class="popup">
    <div class="popup-header">
      <span class="popup-title">Entries</span>
      <span class="entry-count" id="entryCount">0</span>
      <button class="popup-close">&times;</button>
    </div>
    <div class="popup-body" style="display:flex;flex-direction:column;gap:12px;">
      <textarea id="namesInput" placeholder="Enter names, one per line" spellcheck="false" style="flex:1;min-height:250px;background:var(--bg);border:1px solid rgba(255,255,255,0.1);border-radius:8px;padding:12px;color:var(--text);font-family:inherit;font-size:0.9rem;resize:none;"></textarea>
      <div class="sidebar-actions" style="border-top:none;padding:0;">
        <button class="btn-shuffle" id="shuffleBtn">Shuffle</button>
        <button class="btn-reset" id="resetBtn">Clear</button>
      </div>
    </div>
  </div>
</div>

<!-- Configure Popup -->
<div class="popup-overlay" id="popup-configure">
  <div class="popup">
    <div class="popup-header">
      <span class="popup-title">Configure</span>
      <button class="popup-close">&times;</button>
    </div>
    <div class="popup-body">
      <div class="config-panel" id="configPanel" style="padding:0;">
        <!-- Default sound -->
        <div class="config-section">
          <div class="config-section-title">Default Win Sound</div>
          <div style="display:flex;gap:6px;align-items:center;padding:4px 0;">
            <select id="defaultSoundSel" style="flex:1;min-width:0;" title="Default sound for all entries without a custom sound">
              <option value="">Procedural jingle</option>
            </select>
            <input type="range" min="0" max="100" class="vol-slider" id="defaultVolSlider" title="Default volume">
            <span class="vol-label" id="defaultVolLabel">100%</span>
            <button class="preview-btn" id="defaultSoundPreview" title="Preview sound">&#9654;</button>
          </div>
        </div>

        <!-- Default font size -->
        <div class="config-section">
          <div class="config-section-title">Default Font Size</div>
          <div style="display:flex;gap:6px;align-items:center;padding:4px 0;">
            <input type="range" min="6" max="72" value="18" class="vol-slider" style="width:100px;" id="defaultFontSlider" title="Default font size">
            <span class="vol-label" id="defaultFontLabel">18px</span>
          </div>
        </div>

        <!-- Default trigger -->
        <div class="config-section">
          <div class="config-section-title">Default Trigger</div>
          <div style="display:flex;gap:6px;align-items:center;padding:4px 0;">
            <select id="defaultTriggerSel" style="flex:1;min-width:0;" title="Default trigger for entries without a custom trigger">
              <option value="">No trigger</option>
            </select>
          </div>
        </div>

        <!-- Entry sounds + sub-wheel assignments -->
        <div class="config-section">
          <div class="config-section-title">Entry Sounds &amp; Triggers</div>
          <div id="entryConfigList"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="modal-overlay" id="modal">
  <div class="modal">
    <div class="winner-label" id="winnerLabel">Winner</div>
    <div class="winner-name" id="winnerName"></div>
    <div class="modal-buttons">
      <button class="btn-close-modal" id="closeModal">Close</button>
    </div>
  </div>
</div>

<div class="action-overlay" id="actionModal">
  <div class="action-modal">
    <h3 id="actionTitle"></h3>
    <p id="actionDesc"></p>
    <div id="actionBody"></div>
    <div class="action-buttons">
      <button class="btn-action-confirm" id="actionConfirm">Confirm</button>
      <button class="btn-action-cancel" id="actionCancel">Cancel</button>
    </div>
  </div>
</div>

<!-- Betting overlay (appears when player clicks Ready) -->
<div class="ready-overlay" id="readyOverlay">
  <div class="ready-box">
    <h2>Place Your Bet</h2>
    <div class="bet-section" style="border-top:none;margin-top:0;padding-top:0;">
      <div class="bet-row">
        <select id="betEntry" title="Bet on entry"><option value="">Pick an entry...</option></select>
        <input type="number" id="betAmount" min="1" placeholder="$" title="Bet amount">
      </div>
      <button class="bet-confirm" id="betConfirmBtn">Place Bet</button>
      <div class="bet-status" id="betStatus"></div>
    </div>
    <button class="bet-confirm" id="closeBetOverlay" style="background:var(--surface2);color:var(--text-muted);margin-top:4px;">Close</button>
  </div>
</div>

<!-- Bet results toast -->
<div class="bet-results" id="betResults"></div>

<div class="confetti-container" id="confetti"></div>

<script>
(() => {
  const COLORS = [
    '#E74856','#F5A623','#47B04B','#557FC3','#F9D423',
    '#D64DB0','#43B0A8','#EF6C35'
  ];
  const TWO_PI = Math.PI * 2;

  // ── Persisted Config ──
  const STORAGE_KEY = 'wheelSpinConfig';
  const DEFAULT_ENTRIES = 'Add a game\nBloon\'s Multiplayer\nDark Pictures\nDota\nDota Custom Game\nDrink\nHearthstone\nHeathstone\nLegionTD\nLuke\'s Choice\nMechabellum\nMinecraft Minigame\nMinecraft Mod\nSharp\'s Choice\nSpin Again\nStarcraft\nStarcraft Custom\nVintage Story\nZeeb\'s Choice\nAdd a game\nRemove a game';

  function defaultWheelConfig(entries) {
    return { title: 'Main Wheel', entries: entries || '', sounds: {}, volumes: {}, defaultSound: '', defaultVolume: 100, defaultFontSize: 18, fontSizes: {}, triggers: {}, defaultTrigger: '', entryWeights: {} };
  }

  let config = { activeWheelId: null, wheels: {}, shop: [] };
  let selectedWheelId = null;

  function selectedWheelConfig() { return config.wheels[selectedWheelId]; }

  function ensureWheelDefaults(wc) {
    if (!wc.sounds) wc.sounds = {};
    if (!wc.volumes) wc.volumes = {};
    if (!wc.triggers) wc.triggers = {};
    if (!wc.fontSizes) wc.fontSizes = {};
    if (!wc.entryWeights) wc.entryWeights = {};
    if (wc.defaultSound == null) wc.defaultSound = '';
    if (wc.defaultVolume == null) wc.defaultVolume = 100;
    if (wc.defaultFontSize == null) wc.defaultFontSize = 18;
    if (wc.defaultTrigger == null) wc.defaultTrigger = '';
    return wc;
  }

  function migrateConfig(saved) {
    if (saved.wheels) {
      for (const wc of Object.values(saved.wheels)) ensureWheelDefaults(wc);
      return saved;
    }
    const mainId = 'wheel_main';
    const migrated = { activeWheelId: mainId, wheels: {} };
    migrated.wheels[mainId] = {
      title: 'Main Wheel',
      entries: saved.entries || DEFAULT_ENTRIES,
      sounds: saved.sounds || {},
      volumes: saved.volumes || {},
      defaultSound: saved.defaultSound || '',
      defaultVolume: saved.defaultVolume != null ? saved.defaultVolume : 100,
      triggers: {},
    };
    if (saved.subWheels) {
      for (const [id, sw] of Object.entries(saved.subWheels)) {
        migrated.wheels[id] = { title: sw.title || id, entries: sw.entries || '', sounds: {}, volumes: {}, defaultSound: '', defaultVolume: 100, triggers: {} };
      }
    }
    if (saved.triggers) migrated.wheels[mainId].triggers = { ...saved.triggers };
    return migrated;
  }

  // Multiplayer state (declared early so saveConfig can reference it)
  const mp = {
    ws: null,
    connected: false,
    isHost: false,
    clientId: null,
    playerName: '',
    players: [],
    reconnectAttempts: 0,
    maxReconnect: 5,
    lastHost: '',
    lastPort: '',
    send(msg) {
      if (mp.ws && mp.ws.readyState === WebSocket.OPEN) mp.ws.send(JSON.stringify(msg));
    }
  };

  function saveConfig() {
    const wc = selectedWheelConfig();
    if (wc) wc.entries = textarea.value;
    // Non-host clients don't persist remote config locally
    if (mp.connected && !mp.isHost) return;
    try { localStorage.setItem(STORAGE_KEY, JSON.stringify(config)); } catch(e) {}
    // Push to server if host
    if (mp.connected && mp.isHost) {
      mp.send({ type: 'config_update', payload: { config } });
    }
  }

  function loadConfig() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (raw) {
        config = migrateConfig(JSON.parse(raw));
      } else {
        const id = 'wheel_main';
        config = { activeWheelId: id, wheels: {} };
        config.wheels[id] = defaultWheelConfig(DEFAULT_ENTRIES);
      }
    } catch(e) {
      const id = 'wheel_main';
      config = { activeWheelId: id, wheels: {} };
      config.wheels[id] = defaultWheelConfig(DEFAULT_ENTRIES);
    }
    selectedWheelId = config.activeWheelId;
  }

  // ── Sound manifest ──
  // Loaded via <script src="sounds/sounds.js"> which sets window.SOUND_FILES
  let availableSounds = Array.isArray(window.SOUND_FILES) ? window.SOUND_FILES : [];

  // ── DOM ──
  const spinBtn = document.getElementById('spinBtn');
  const textarea = document.getElementById('namesInput');
  const countEl = document.getElementById('entryCount');
  const modal = document.getElementById('modal');
  const winnerEl = document.getElementById('winnerName');
  const winnerLabelEl = document.getElementById('winnerLabel');
  const closeBtn = document.getElementById('closeModal');
  const shuffleBtn = document.getElementById('shuffleBtn');
  const resetBtn = document.getElementById('resetBtn');
  const confettiContainer = document.getElementById('confetti');
  const configPanel = document.getElementById('configPanel');
  const entryConfigList = document.getElementById('entryConfigList');
  const wheelSelect = document.getElementById('wheelSelect');

  // ── Popup menus ──
  function openPopup(name) {
    document.querySelectorAll('.popup-overlay').forEach(p => p.classList.remove('show'));
    document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active'));
    const popup = document.getElementById('popup-' + name);
    const btn = document.querySelector('.menu-btn[data-popup="' + name + '"]');
    if (popup) popup.classList.add('show');
    if (btn) btn.classList.add('active');

    // Refresh content when opened
    if (name === 'configure') rebuildConfigUI();
    if (name === 'shop') { rebuildShopUI(); refreshBoostPanel(); }
    if (name === 'market') {
      rebuildMarketUI();
      mp.send({ type: 'get_orders' }); // Request orders data
    }
  }

  function closePopup() {
    document.querySelectorAll('.popup-overlay').forEach(p => p.classList.remove('show'));
    document.querySelectorAll('.menu-btn').forEach(b => b.classList.remove('active'));
  }

  // Menu button click handlers
  document.querySelectorAll('.menu-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const popupName = btn.dataset.popup;
      const popup = document.getElementById('popup-' + popupName);
      // Toggle: if already open, close it
      if (popup && popup.classList.contains('show')) {
        closePopup();
      } else {
        openPopup(popupName);
      }
    });
  });

  // Close button handlers
  document.querySelectorAll('.popup-close').forEach(btn => {
    btn.addEventListener('click', closePopup);
  });

  // Click outside popup to close
  document.querySelectorAll('.popup-overlay').forEach(overlay => {
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) closePopup();
    });
  });

  // ESC key closes popup
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') closePopup();
  });

  // ── Audio Context ──
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playTick() {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = 'sine';
    osc.frequency.value = 1800 + Math.random() * 600;
    gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.06);
    osc.start();
    osc.stop(audioCtx.currentTime + 0.06);
  }

  function playJingle(vol) {
    const v = (vol != null ? vol : 1) * 0.12;
    [523, 659, 784, 1047].forEach((freq, i) => {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.type = 'triangle';
      osc.frequency.value = freq;
      const t = audioCtx.currentTime + i * 0.12;
      gain.gain.setValueAtTime(v, t);
      gain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
      osc.start(t);
      osc.stop(t + 0.3);
    });
  }

  function playCheer() {
    const duration = 1.5;
    const bufferSize = audioCtx.sampleRate * duration;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    const bp = audioCtx.createBiquadFilter();
    bp.type = 'bandpass'; bp.frequency.value = 1200; bp.Q.value = 0.5;
    const gain = audioCtx.createGain();
    const now = audioCtx.currentTime;
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.15, now + 0.15);
    gain.gain.setValueAtTime(0.15, now + 0.5);
    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
    source.connect(bp); bp.connect(gain); gain.connect(audioCtx.destination);
    source.start(now); source.stop(now + duration);
  }

  const soundCache = {};
  function playSoundFile(file, vol) {
    const path = 'sounds/' + file;
    if (!soundCache[path]) soundCache[path] = new Audio(path);
    const audio = soundCache[path];
    audio.volume = vol != null ? vol : 1;
    audio.currentTime = 0;
    audio.play().catch(() => {});
  }

  function getVolume(name, wheelId) {
    const wc = config.wheels[wheelId || config.activeWheelId];
    if (!wc) return 1;
    if (wc.volumes[name] != null) return wc.volumes[name] / 100;
    return (wc.defaultVolume != null ? wc.defaultVolume : 100) / 100;
  }

  function playWinSound(name, wheelId) {
    const wc = config.wheels[wheelId || config.activeWheelId];
    if (!wc) return;
    const vol = getVolume(name, wheelId);
    const entryFile = wc.sounds[name];
    if (entryFile) {
      playSoundFile(entryFile, vol);
    } else if (wc.defaultSound) {
      playSoundFile(wc.defaultSound, vol);
    } else {
      playJingle(vol);
    }
    playCheer();
  }

  // ── Utility ──
  function luma(hex) {
    const c = hex.replace('#','');
    return 0.2126*(parseInt(c.substring(0,2),16)/255) +
           0.7152*(parseInt(c.substring(2,4),16)/255) +
           0.0722*(parseInt(c.substring(4,6),16)/255);
  }

  function segmentAtAngle(segments, angle) {
    const a = ((angle % TWO_PI) + TWO_PI) % TWO_PI;
    for (let i = 0; i < segments.length; i++) if (a < segments[i].end) return i;
    return segments.length - 1;
  }

  function cryptoRandom() {
    const arr = new Uint32Array(1);
    crypto.getRandomValues(arr);
    return arr[0] / 0xFFFFFFFF;
  }

  // ═══════════════════════════════════════════════════════════════
  // ── Wheel Context ──
  // ═══════════════════════════════════════════════════════════════

  function createWheel(canvasOrId, pointerOrId) {
    const canvas = typeof canvasOrId === 'string' ? document.getElementById(canvasOrId) : canvasOrId;
    const ctx = canvas.getContext('2d');
    const pointerEl = typeof pointerOrId === 'string' ? document.getElementById(pointerOrId) : pointerOrId;
    const w = {
      canvas, ctx, pointerEl,
      names: [], rotation: 0, spinning: false, animFrame: null,
      cooldowns: new Map(),
      offscreen: null, offCtx: null, cachedSegments: [], layoutDirty: true,
      defaultFontSize: 18, fontSizes: {},  // set externally before draw
      hoveredSegment: -1, // currently hovered segment index (-1 = none)
    };

    w.entryWeights = {};
    w.getWeight = (n, idx) => {
      const base = w.entryWeights[n] != null ? w.entryWeights[n] : 1;
      // Index-based boost overrides (for duplicate entries)
      const idxKey = '__idx_' + idx;
      const idxBoost = w.entryWeights[idxKey] != null ? w.entryWeights[idxKey] : 0;
      const cd = w.cooldowns.get(n);
      return (base + idxBoost) * (cd ? cd.weight : 1);
    };
    w.invalidateLayout = () => { w.layoutDirty = true; };

    w.rebuildLayout = () => {
      if (!w.layoutDirty && w.cachedSegments.length === w.names.length) return;
      w.layoutDirty = false;
      const weights = w.names.map((n, i) => w.getWeight(n, i));
      const total = weights.reduce((a, b) => a + b, 0);
      w.cachedSegments = [];
      let cursor = 0;
      for (let i = 0; i < w.names.length; i++) {
        const arc = (weights[i] / total) * TWO_PI;
        w.cachedSegments.push({ start: cursor, arc, end: cursor + arc });
        cursor += arc;
      }
      const size = w.canvas.width;
      if (!w.offscreen || w.offscreen.width !== size) {
        w.offscreen = document.createElement('canvas');
        w.offscreen.width = size; w.offscreen.height = size;
        w.offCtx = w.offscreen.getContext('2d');
      }
      const oc = w.offCtx, cx = size/2, r = cx*0.92, maxLen = r*0.75;
      const cssSize = size / devicePixelRatio;
      const fontScale = cssSize / 500; // scale fonts proportionally to wheel size
      oc.clearRect(0,0,size,size);
      oc.save(); oc.translate(cx,cx);
      for (let i = 0; i < w.names.length; i++) {
        const seg = w.cachedSegments[i];
        oc.beginPath(); oc.moveTo(0,0); oc.arc(0,0,r,seg.start,seg.end); oc.closePath();
        oc.fillStyle = COLORS[i%COLORS.length]; oc.fill();
        oc.strokeStyle = 'rgba(0,0,0,0.25)'; oc.lineWidth = 3*devicePixelRatio; oc.stroke();
        oc.save(); oc.rotate(seg.start+seg.arc/2);
        oc.textAlign = 'right'; oc.textBaseline = 'middle';
        const baseFontSize = (w.fontSizes[w.names[i]] != null ? w.fontSizes[w.names[i]] : w.defaultFontSize) || 18;
        let fs = Math.min(baseFontSize * devicePixelRatio * Math.min(fontScale, 1), seg.arc*r*0.45);
        fs = Math.max(fs, 4*devicePixelRatio * Math.min(fontScale, 0.6));
        oc.font = `600 ${fs}px "Nunito","Segoe UI",system-ui,sans-serif`;
        let label = w.names[i];
        while (oc.measureText(label).width > maxLen && label.length > 1) label = label.slice(0,-1);
        if (label !== w.names[i]) label += '…';
        oc.fillStyle = luma(COLORS[i%COLORS.length]) > 0.55 ? '#1a1a2e' : '#fff';
        oc.shadowColor = 'rgba(0,0,0,0.35)'; oc.shadowBlur = 3*devicePixelRatio;
        oc.fillText(label, r*0.93, 0);
        oc.restore();
      }
      oc.beginPath(); oc.arc(0,0,r+2*devicePixelRatio,0,TWO_PI);
      oc.strokeStyle = 'rgba(255,255,255,0.08)'; oc.lineWidth = 5*devicePixelRatio; oc.stroke();
      oc.restore();
    };

    w.resizeCanvas = () => {
      const cell = w.canvas.parentElement.parentElement; // .wheel-cell
      const cellRect = cell.getBoundingClientRect();
      // Account for title height
      const titleEl = cell.querySelector('.wheel-cell-title');
      const titleH = titleEl ? titleEl.getBoundingClientRect().height + 4 : 0;
      const availW = cellRect.width;
      const availH = cellRect.height - titleH;
      // Responsive max size based on viewport
      const vw = window.innerWidth, vh = window.innerHeight;
      let maxSize = 500; // default max
      if (vw <= 600 || vh <= 500) maxSize = Math.min(320, vh * 0.55);
      else if (vw <= 900 || vh <= 700) maxSize = Math.min(400, vh * 0.6);
      else maxSize = Math.min(500, vh * 0.7);
      const size = Math.max(Math.min(availW, availH, maxSize), 50);
      const inner = w.canvas.parentElement;
      inner.style.width = size + 'px';
      inner.style.height = size + 'px';
      w.canvas.width = size*devicePixelRatio; w.canvas.height = size*devicePixelRatio;
      // Scale pointer and center button proportionally to wheel size
      const scale = Math.min(size / 500, 1); // 500px is our reference size, never scale up
      const pEl = cell.querySelector('.pointer');
      if (pEl) {
        const bw = Math.round(18 * scale);
        const bh = Math.round(38 * scale);
        pEl.style.borderLeftWidth = bw + 'px';
        pEl.style.borderRightWidth = bw + 'px';
        pEl.style.borderTopWidth = bh + 'px';
        pEl.style.top = -Math.round(bh * 0.47) + 'px';
      }
      const cBtn = cell.querySelector('.center-btn');
      if (cBtn) {
        const btnSize = Math.round(170 * scale);
        const btnFont = Math.max(0.5, 1.5 * scale);
        const btnBorder = Math.max(2, Math.round(7 * scale));
        cBtn.style.width = btnSize + 'px';
        cBtn.style.height = btnSize + 'px';
        cBtn.style.fontSize = btnFont + 'rem';
        cBtn.style.borderWidth = btnBorder + 'px';
      }
      w.invalidateLayout(); w.draw();
    };

    w.draw = () => {
      const cw = w.canvas.width, ch = w.canvas.height, cx = cw/2, cy = ch/2;
      w.ctx.clearRect(0,0,cw,ch);
      if (w.names.length === 0) {
        const r = cx*0.92;
        w.ctx.save();
        w.ctx.beginPath(); w.ctx.arc(cx,cy,r,0,TWO_PI);
        w.ctx.fillStyle = '#1e2a45'; w.ctx.fill();
        w.ctx.strokeStyle = 'rgba(233,69,96,0.3)'; w.ctx.lineWidth = 4*devicePixelRatio; w.ctx.stroke();
        w.ctx.fillStyle = '#556';
        w.ctx.font = `${16*devicePixelRatio}px "Nunito","Segoe UI",system-ui,sans-serif`;
        w.ctx.textAlign = 'center'; w.ctx.textBaseline = 'middle';
        w.ctx.fillText('No entries', cx, cy);
        w.ctx.restore();
        return;
      }
      w.rebuildLayout();
      w.ctx.save(); w.ctx.translate(cx,cy); w.ctx.rotate(w.rotation);
      w.ctx.drawImage(w.offscreen, -cx, -cy);
      // Draw hover highlight
      if (w.hoveredSegment >= 0 && w.hoveredSegment < w.cachedSegments.length && !w.spinning) {
        const seg = w.cachedSegments[w.hoveredSegment];
        const r = cx * 0.92;
        w.ctx.beginPath();
        w.ctx.moveTo(0, 0);
        w.ctx.arc(0, 0, r, seg.start, seg.end);
        w.ctx.closePath();
        w.ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
        w.ctx.fill();
        w.ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        w.ctx.lineWidth = 3 * devicePixelRatio;
        w.ctx.stroke();
      }
      w.ctx.restore();
    };

    w.spin = (onFinish) => {
      if (w.spinning || w.names.length < 2) return;
      w.spinning = true;
      w.rebuildLayout();
      const segments = w.cachedSegments;
      const landAngle = cryptoRandom() * TWO_PI;
      const winnerIndex = segmentAtAngle(segments, landAngle);
      const targetAngle = -Math.PI/2 - landAngle;
      const minSpins = 6 + Math.floor(Math.random() * 5); // 6-10 revolutions
      let adj = targetAngle;
      while (adj <= w.rotation + minSpins * TWO_PI) adj += TWO_PI;
      const startR = w.rotation, delta = adj - startR;
      const dur = 9000 + Math.random()*3000, startT = performance.now(); // 9-12 seconds
      const easePow = 5; // quintic easing — gold standard for wheel spinners
      let lastSeg = -1;
      function anim(now) {
        const t = Math.min((now-startT)/dur, 1);
        w.rotation = startR + delta * (1 - Math.pow(1-t, easePow));
        const pa = (((-w.rotation - Math.PI/2) % TWO_PI) + TWO_PI) % TWO_PI;
        const cs = segmentAtAngle(segments, pa);
        if (cs !== lastSeg) {
          lastSeg = cs; playTick();
          w.pointerEl.classList.add('tick');
          setTimeout(() => w.pointerEl.classList.remove('tick'), 50);
        }
        w.draw();
        if (t < 1) w.animFrame = requestAnimationFrame(anim);
        else { w.spinning = false; if (onFinish) onFinish(w.names[winnerIndex]); }
      }
      w.animFrame = requestAnimationFrame(anim);
    };

    return w;
  }

  const mainWheel = createWheel('mainCanvas', 'mainPointer');
  const wheelPanel = document.getElementById('wheelPanel');
  const mainCell = document.getElementById('mainCell');
  let subWheelCells = []; // {element, wheel, wheelId}

  function updateGridCols() {
    const total = 1 + subWheelCells.length;
    wheelPanel.classList.remove('cols-2', 'cols-3');
    if (total >= 3) wheelPanel.classList.add('cols-3');
    else if (total === 2) wheelPanel.classList.add('cols-2');
  }

  function createWheelCell(title) {
    const cell = document.createElement('div');
    cell.className = 'wheel-cell sub-cell';

    const titleEl = document.createElement('div');
    titleEl.className = 'wheel-cell-title';
    titleEl.textContent = title;
    cell.appendChild(titleEl);

    const inner = document.createElement('div');
    inner.className = 'wheel-cell-inner';

    const pointer = document.createElement('div');
    pointer.className = 'pointer';
    inner.appendChild(pointer);

    const canvas = document.createElement('canvas');
    canvas.className = 'wheel-canvas';
    inner.appendChild(canvas);

    const btn = document.createElement('button');
    btn.className = 'center-btn';
    btn.disabled = true;
    btn.textContent = 'SUB';
    inner.appendChild(btn);

    cell.appendChild(inner);
    wheelPanel.appendChild(cell);

    const wheel = createWheel(canvas, pointer);
    subWheelCells.push({ element: cell, wheel, titleEl });
    updateGridCols();
    return { cell, wheel };
  }

  function clearSubWheels() {
    for (const sc of subWheelCells) {
      if (sc.wheel.animFrame) cancelAnimationFrame(sc.wheel.animFrame);
      sc.element.remove();
    }
    subWheelCells = [];
    updateGridCols();
  }

  function resizeAllWheels() {
    mainWheel.resizeCanvas();
    for (const sc of subWheelCells) sc.wheel.resizeCanvas();
    // Redraw chart if market is open and stock selected
    if (selectedStock && currentStockPrices[selectedStock]) {
      const popup = document.getElementById('popup-market');
      if (popup && popup.classList.contains('show')) {
        selectStock(selectedStock);
      }
    }
  }

  // ── Cooldown ──
  const CD_FLOOR = 0.2, CD_RECOVERY = 0.16;
  function applyCD(name) { mainWheel.cooldowns.set(name, { weight: CD_FLOOR }); }
  function advanceCD(exclude) {
    for (const [n, cd] of mainWheel.cooldowns) {
      if (n === exclude) continue;
      cd.weight = Math.min(1, cd.weight + CD_RECOVERY);
      if (cd.weight >= 1) mainWheel.cooldowns.delete(n);
    }
  }

  // ── Names ──
  function getNames() { return textarea.value.split('\n').map(s => s.trim()).filter(Boolean); }

  function syncWheelConfig(wheel, wc) {
    wheel.defaultFontSize = wc.defaultFontSize != null ? wc.defaultFontSize : 18;
    wheel.fontSizes = wc.fontSizes || {};
    wheel.entryWeights = wc.entryWeights || {};
  }

  function updateNames() {
    const names = getNames();
    countEl.textContent = names.length;
    if (selectedWheelId === config.activeWheelId) {
      const wc = selectedWheelConfig();
      if (wc) syncWheelConfig(mainWheel, wc);
      mainWheel.names = names;
      mainWheel.invalidateLayout();
      mainWheel.draw();
    }
    saveConfig();
  }

  // ── Wheel Selector ──
  function rebuildWheelSelector() {
    wheelSelect.innerHTML = '';
    for (const [id, wc] of Object.entries(config.wheels)) {
      const opt = document.createElement('option');
      opt.value = id;
      opt.textContent = wc.title || id;
      if (id === selectedWheelId) opt.selected = true;
      wheelSelect.appendChild(opt);
    }
  }

  function switchToWheel(wheelId) {
    const oldWc = selectedWheelConfig();
    if (oldWc) oldWc.entries = textarea.value;

    selectedWheelId = wheelId;
    config.activeWheelId = wheelId;

    const wc = selectedWheelConfig();
    textarea.value = wc ? wc.entries || '' : '';
    const names = getNames();
    if (wc) syncWheelConfig(mainWheel, wc);
    mainWheel.names = names;
    mainWheel.cooldowns.clear();
    mainWheel.rotation = 0;
    mainWheel.invalidateLayout();
    mainWheel.draw();
    countEl.textContent = names.length;
    rebuildConfigUI();
    saveConfig();
  }

  wheelSelect.addEventListener('change', () => switchToWheel(wheelSelect.value));

  document.getElementById('addWheelBtn').addEventListener('click', () => {
    const id = 'wheel_' + Date.now();
    config.wheels[id] = defaultWheelConfig('');
    config.wheels[id].title = 'New Wheel';
    saveConfig();
    rebuildWheelSelector();
    switchToWheel(id);
  });

  document.getElementById('renameWheelBtn').addEventListener('click', () => {
    const wc = selectedWheelConfig();
    if (!wc) return;
    const newTitle = prompt('Wheel name:', wc.title);
    if (newTitle != null && newTitle.trim()) {
      wc.title = newTitle.trim();
      saveConfig();
      rebuildWheelSelector();
    }
  });

  document.getElementById('deleteWheelBtn').addEventListener('click', () => {
    const ids = Object.keys(config.wheels);
    if (ids.length <= 1) return;
    const wc = selectedWheelConfig();
    if (!confirm('Delete "' + (wc ? wc.title : '') + '"?')) return;
    const deadId = selectedWheelId;
    delete config.wheels[deadId];
    for (const w of Object.values(config.wheels)) {
      for (const [entry, targetId] of Object.entries(w.triggers)) {
        if (targetId === deadId) delete w.triggers[entry];
      }
    }
    const remaining = Object.keys(config.wheels)[0];
    config.activeWheelId = remaining;
    saveConfig();
    rebuildWheelSelector();
    switchToWheel(remaining);
  });

  // ── Config UI ──
  function rebuildConfigUI() {
    rebuildDefaultSound();
    rebuildDefaultFont();
    rebuildDefaultTrigger();
    rebuildEntryConfig();
  }

  function rebuildDefaultTrigger() {
    const wc = selectedWheelConfig();
    if (!wc) return;
    const sel = document.getElementById('defaultTriggerSel');
    sel.innerHTML = '';

    const noneOpt = document.createElement('option');
    noneOpt.value = ''; noneOpt.textContent = 'No trigger';
    if (!wc.defaultTrigger) noneOpt.selected = true;
    sel.appendChild(noneOpt);

    // Action triggers
    const actGroup = document.createElement('optgroup');
    actGroup.label = 'Actions';
    [['__add_entry', 'Add Entry'], ['__remove_entry', 'Remove Entry'], ['__spin_again', 'Spin Again']].forEach(([val, lbl]) => {
      const opt = document.createElement('option');
      opt.value = val; opt.textContent = lbl;
      if (wc.defaultTrigger === val) opt.selected = true;
      actGroup.appendChild(opt);
    });
    sel.appendChild(actGroup);

    // Sub-wheel triggers
    const otherWheels = Object.entries(config.wheels).filter(([id]) => id !== selectedWheelId);
    if (otherWheels.length) {
      const wGroup = document.createElement('optgroup');
      wGroup.label = 'Sub-Wheels';
      otherWheels.forEach(([id, other]) => {
        const opt = document.createElement('option');
        opt.value = id; opt.textContent = other.title || id;
        if (wc.defaultTrigger === id) opt.selected = true;
        wGroup.appendChild(opt);
      });
      sel.appendChild(wGroup);
    }

    sel.onchange = () => { wc.defaultTrigger = sel.value; saveConfig(); };
  }

  function rebuildDefaultSound() {
    const wc = selectedWheelConfig();
    if (!wc) return;
    const sel = document.getElementById('defaultSoundSel');
    const prevBtn = document.getElementById('defaultSoundPreview');
    const volSlider = document.getElementById('defaultVolSlider');
    const volLabel = document.getElementById('defaultVolLabel');
    sel.length = 1;
    availableSounds.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f; opt.textContent = f.replace(/\.[^.]+$/, '');
      if (wc.defaultSound === f) opt.selected = true;
      sel.appendChild(opt);
    });
    sel.onchange = () => { wc.defaultSound = sel.value; saveConfig(); };
    volSlider.value = wc.defaultVolume != null ? wc.defaultVolume : 100;
    volLabel.textContent = volSlider.value + '%';
    volSlider.oninput = () => {
      volLabel.textContent = volSlider.value + '%';
      wc.defaultVolume = parseInt(volSlider.value);
      saveConfig();
    };
    prevBtn.onclick = () => {
      const v = parseInt(volSlider.value) / 100;
      if (sel.value) { playSoundFile(sel.value, v); }
      else { playJingle(v); }
    };
  }

  function rebuildDefaultFont() {
    const wc = selectedWheelConfig();
    if (!wc) return;
    const slider = document.getElementById('defaultFontSlider');
    const label = document.getElementById('defaultFontLabel');
    slider.value = wc.defaultFontSize != null ? wc.defaultFontSize : 18;
    label.textContent = slider.value + 'px';
    slider.oninput = () => {
      label.textContent = slider.value + 'px';
      wc.defaultFontSize = parseInt(slider.value);
      saveConfig();
      if (selectedWheelId === config.activeWheelId) {
        mainWheel.invalidateLayout();
        mainWheel.draw();
      }
    };
  }

  function rebuildEntryConfig() {
    const wc = selectedWheelConfig();
    if (!wc) return;
    const names = getNames();
    entryConfigList.innerHTML = '';
    const otherWheels = Object.entries(config.wheels).filter(([id]) => id !== selectedWheelId);

    names.forEach(name => {
      const row = document.createElement('div');
      row.className = 'config-entry';

      const label = document.createElement('span');
      label.className = 'config-entry-name';
      label.textContent = name;
      label.title = name;

      // sound dropdown
      const soundSel = document.createElement('select');
      soundSel.title = 'Win sound';
      const noneOpt = document.createElement('option');
      noneOpt.value = ''; noneOpt.textContent = 'Default';
      soundSel.appendChild(noneOpt);
      availableSounds.forEach(f => {
        const opt = document.createElement('option');
        opt.value = f; opt.textContent = f.replace(/\.[^.]+$/, '');
        if (wc.sounds[name] === f) opt.selected = true;
        soundSel.appendChild(opt);
      });
      soundSel.addEventListener('change', () => {
        if (soundSel.value) wc.sounds[name] = soundSel.value;
        else delete wc.sounds[name];
        saveConfig();
      });

      // volume slider
      const vol = document.createElement('input');
      vol.type = 'range'; vol.min = 0; vol.max = 100;
      vol.className = 'vol-slider';
      vol.value = wc.volumes[name] != null ? wc.volumes[name] : (wc.defaultVolume != null ? wc.defaultVolume : 100);
      vol.title = 'Volume';
      const volLabel = document.createElement('span');
      volLabel.className = 'vol-label';
      volLabel.textContent = vol.value + '%';
      vol.addEventListener('input', () => {
        volLabel.textContent = vol.value + '%';
        wc.volumes[name] = parseInt(vol.value);
        saveConfig();
      });

      // preview button
      const prevBtn = document.createElement('button');
      prevBtn.className = 'preview-btn';
      prevBtn.textContent = '\u25B6';
      prevBtn.title = 'Preview sound';
      prevBtn.addEventListener('click', () => {
        const file = soundSel.value || wc.defaultSound;
        if (file) { playSoundFile(file, parseInt(vol.value) / 100); }
        else { playJingle(parseInt(vol.value) / 100); }
      });

      // font size: default/custom toggle + slider
      const hasCustomFont = wc.fontSizes[name] != null;
      const fsSel = document.createElement('select');
      fsSel.title = 'Font size mode';
      const fsOptDef = document.createElement('option');
      fsOptDef.value = 'default'; fsOptDef.textContent = 'Default';
      const fsOptCust = document.createElement('option');
      fsOptCust.value = 'custom'; fsOptCust.textContent = 'Custom';
      if (hasCustomFont) fsOptCust.selected = true;
      fsSel.appendChild(fsOptDef);
      fsSel.appendChild(fsOptCust);

      const fs = document.createElement('input');
      fs.type = 'range'; fs.min = 6; fs.max = 72;
      fs.className = 'fs-slider';
      fs.value = hasCustomFont ? wc.fontSizes[name] : (wc.defaultFontSize != null ? wc.defaultFontSize : 18);
      fs.title = 'Font size';
      const fsLabel = document.createElement('span');
      fsLabel.className = 'fs-label';
      fsLabel.textContent = fs.value + 'px';

      // Hide slider when default
      fs.style.display = hasCustomFont ? '' : 'none';
      fsLabel.style.display = hasCustomFont ? '' : 'none';

      fsSel.addEventListener('change', () => {
        if (fsSel.value === 'custom') {
          fs.style.display = ''; fsLabel.style.display = '';
          wc.fontSizes[name] = parseInt(fs.value);
        } else {
          fs.style.display = 'none'; fsLabel.style.display = 'none';
          delete wc.fontSizes[name];
        }
        saveConfig();
        if (selectedWheelId === config.activeWheelId) {
          mainWheel.invalidateLayout();
          mainWheel.draw();
        }
      });

      fs.addEventListener('input', () => {
        fsLabel.textContent = fs.value + 'px';
        wc.fontSizes[name] = parseInt(fs.value);
        saveConfig();
        if (selectedWheelId === config.activeWheelId) {
          mainWheel.invalidateLayout();
          mainWheel.draw();
        }
      });

      // trigger dropdown (actions + sub-wheels)
      const swSel = document.createElement('select');
      swSel.title = 'Trigger';
      const swNone = document.createElement('option');
      swNone.value = ''; swNone.textContent = 'Use Default';
      swSel.appendChild(swNone);

      const swExplicitNone = document.createElement('option');
      swExplicitNone.value = '__none'; swExplicitNone.textContent = 'No trigger';
      if (wc.triggers[name] === '__none') swExplicitNone.selected = true;
      swSel.appendChild(swExplicitNone);

      // Action triggers
      const actGroup = document.createElement('optgroup');
      actGroup.label = 'Actions';
      [['__add_entry', 'Add Entry'], ['__remove_entry', 'Remove Entry'], ['__spin_again', 'Spin Again']].forEach(([val, lbl]) => {
        const opt = document.createElement('option');
        opt.value = val; opt.textContent = lbl;
        if (wc.triggers[name] === val) opt.selected = true;
        actGroup.appendChild(opt);
      });
      swSel.appendChild(actGroup);

      // Sub-wheel triggers
      if (otherWheels.length) {
        const wGroup = document.createElement('optgroup');
        wGroup.label = 'Sub-Wheels';
        otherWheels.forEach(([id, other]) => {
          const opt = document.createElement('option');
          opt.value = id;
          opt.textContent = other.title || id;
          if (wc.triggers[name] === id) opt.selected = true;
          wGroup.appendChild(opt);
        });
        swSel.appendChild(wGroup);
      }

      swSel.addEventListener('change', () => {
        if (swSel.value) wc.triggers[name] = swSel.value;
        else delete wc.triggers[name];
        saveConfig();
      });

      // Helper to build a labeled row
      function makeRow(labelText, ...children) {
        const r = document.createElement('div');
        r.className = 'config-entry-row';
        const lbl = document.createElement('span');
        lbl.className = 'config-entry-row-label';
        lbl.textContent = labelText;
        r.appendChild(lbl);
        children.forEach(c => r.appendChild(c));
        return r;
      }

      // weight slider
      const wt = document.createElement('input');
      wt.type = 'range'; wt.min = 1; wt.max = 10; wt.step = 1;
      wt.className = 'vol-slider';
      wt.value = wc.entryWeights[name] != null ? wc.entryWeights[name] : 1;
      wt.title = 'Weight (chance multiplier)';
      const wtLabel = document.createElement('span');
      wtLabel.className = 'vol-label';
      wtLabel.textContent = wt.value + 'x';
      wt.addEventListener('input', () => {
        wtLabel.textContent = wt.value + 'x';
        const v = parseInt(wt.value);
        if (v === 1) delete wc.entryWeights[name];
        else wc.entryWeights[name] = v;
        saveConfig();
        if (selectedWheelId === config.activeWheelId) {
          mainWheel.entryWeights = wc.entryWeights;
          mainWheel.invalidateLayout();
          mainWheel.draw();
        }
      });

      row.appendChild(label);
      row.appendChild(makeRow('Sound', soundSel, vol, volLabel, prevBtn));
      row.appendChild(makeRow('Font', fsSel, fs, fsLabel));
      row.appendChild(makeRow('Weight', wt, wtLabel));
      row.appendChild(makeRow('Trigger', swSel));
      entryConfigList.appendChild(row);
    });
  }

  // ── Action Modal ──
  const actionOverlay = document.getElementById('actionModal');
  const actionTitle = document.getElementById('actionTitle');
  const actionDesc = document.getElementById('actionDesc');
  const actionBody = document.getElementById('actionBody');
  const actionConfirm = document.getElementById('actionConfirm');
  const actionCancel = document.getElementById('actionCancel');
  let actionCleanup = null;

  function showActionModal(title, desc, bodyHTML, onConfirm, onCancel) {
    actionTitle.textContent = title;
    actionDesc.textContent = desc;
    actionBody.innerHTML = bodyHTML;
    actionOverlay.classList.add('show');
    if (actionCleanup) actionCleanup();
    const confirmHandler = () => {
      actionOverlay.classList.remove('show');
      cleanup();
      if (onConfirm) onConfirm();
    };
    const cancelHandler = () => {
      actionOverlay.classList.remove('show');
      cleanup();
      if (onCancel) onCancel();
    };
    function cleanup() {
      actionConfirm.removeEventListener('click', confirmHandler);
      actionCancel.removeEventListener('click', cancelHandler);
      actionCleanup = null;
    }
    actionConfirm.addEventListener('click', confirmHandler);
    actionCancel.addEventListener('click', cancelHandler);
    actionCleanup = cleanup;
    // Focus the first input/select if present
    const focusEl = actionBody.querySelector('input, select');
    if (focusEl) setTimeout(() => focusEl.focus(), 100);
  }

  function handleAddEntry(wheelId) {
    showActionModal(
      'Add an Entry',
      'You must add a new entry to the wheel!',
      '<input type="text" id="actionInput" placeholder="Enter new name..." />',
      () => {
        const input = document.getElementById('actionInput');
        const val = input ? input.value.trim() : '';
        if (!val) return;
        const wc = config.wheels[wheelId];
        if (!wc) return;
        wc.entries = wc.entries ? wc.entries + '\n' + val : val;
        if (wheelId === selectedWheelId) {
          textarea.value = wc.entries;
          updateNames();
        } else {
          saveConfig();
        }
      }
    );
    // Allow Enter key to confirm
    setTimeout(() => {
      const input = document.getElementById('actionInput');
      if (input) input.addEventListener('keydown', e => {
        if (e.key === 'Enter') actionConfirm.click();
      });
    }, 50);
  }

  function handleRemoveEntry(wheelId) {
    const wc = config.wheels[wheelId];
    if (!wc) return;
    const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
    if (entries.length === 0) return;
    const options = entries.map(e => `<option value="${e.replace(/"/g, '&quot;')}">${e}</option>`).join('');
    showActionModal(
      'Remove an Entry',
      'You must remove an entry from the wheel!',
      `<select id="actionSelect">${options}</select>`,
      () => {
        const sel = document.getElementById('actionSelect');
        const val = sel ? sel.value : '';
        if (!val) return;
        // Remove first occurrence of the entry
        const lines = (wc.entries || '').split('\n');
        let removed = false;
        const newLines = lines.filter(l => {
          if (!removed && l.trim() === val) { removed = true; return false; }
          return true;
        });
        wc.entries = newLines.join('\n');
        // Clean up sound/volume/trigger/fontSize refs for this entry if it no longer exists
        const remaining = newLines.map(s => s.trim()).filter(Boolean);
        if (!remaining.includes(val)) {
          delete wc.sounds[val];
          delete wc.volumes[val];
          delete wc.triggers[val];
          delete wc.fontSizes[val];
          delete wc.entryWeights[val];
        }
        if (wheelId === selectedWheelId) {
          textarea.value = wc.entries;
          updateNames();
        } else {
          saveConfig();
        }
      }
    );
  }

  function handleSpinAgain(winner, wheelId) {
    // Play the win sound for the spin-again entry, then re-spin
    playWinSound(winner, wheelId);
    showToast(winner, 'Spin Again!');
    startConfetti();
    setTimeout(() => {
      hideToast();
      stopConfetti();
      doMainSpin();
    }, 1500);
  }

  // ── Main Spin ──
  function doMainSpin() {
    if (mainWheel.spinning || mainWheel.names.length < 2) return;
    clearSubWheels();
    resizeAllWheels();
    spinBtn.disabled = true;
    const wheelId = config.activeWheelId;
    mainWheel.spin((winner) => {
      spinBtn.disabled = false;
      advanceCD(winner);
      applyCD(winner);
      mainWheel.invalidateLayout();

      const wc = config.wheels[wheelId];
      const perEntry = wc && wc.triggers && wc.triggers[winner];
      const trigger = perEntry === '__none' ? '' : (perEntry || (wc && wc.defaultTrigger) || '');

      if (trigger === '__add_entry') {
        playWinSound(winner, wheelId);
        showToast(winner, 'Add Entry!');
        startConfetti();
        setTimeout(() => { hideToast(); stopConfetti(); handleAddEntry(wheelId); }, 1200);
      } else if (trigger === '__remove_entry') {
        playWinSound(winner, wheelId);
        showToast(winner, 'Remove Entry!');
        startConfetti();
        setTimeout(() => { hideToast(); stopConfetti(); handleRemoveEntry(wheelId); }, 1200);
      } else if (trigger === '__spin_again') {
        handleSpinAgain(winner, wheelId);
      } else if (trigger && config.wheels[trigger]) {
        // Sub-wheel trigger
        showToast(winner, 'Winner');
        startConfetti();
        playWinSound(winner, wheelId);
        launchSubWheel(trigger, new Set([wheelId]));
      } else {
        showWinner(winner, 'Winner');
        playWinSound(winner, wheelId);
      }
    });
  }

  // ── Sub-wheel ──
  function launchSubWheel(wheelId, visited) {
    if (!visited) visited = new Set();
    if (visited.has(wheelId)) return;
    visited.add(wheelId);

    const wc = config.wheels[wheelId];
    if (!wc) return;
    const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
    if (entries.length < 2) return;

    const { cell, wheel } = createWheelCell(wc.title || wheelId);
    syncWheelConfig(wheel, wc);
    wheel.names = entries;
    wheel.rotation = 0;
    wheel.cooldowns.clear();
    wheel.invalidateLayout();

    // Let grid reflow, then resize and spin
    setTimeout(() => {
      resizeAllWheels();
      wheel.draw();
      setTimeout(() => {
        wheel.spin((subWinner) => {
          playWinSound(subWinner, wheelId);
          const subPerEntry = wc.triggers && wc.triggers[subWinner];
          const nextTriggerId = subPerEntry === '__none' ? '' : (subPerEntry || wc.defaultTrigger || '');
          const canChain = nextTriggerId && config.wheels[nextTriggerId] && !visited.has(nextTriggerId);
          hideToast();
          if (canChain) {
            showToast(subWinner, wc.title || 'Sub-Wheel');
            startConfetti();
            setTimeout(() => {
              hideToast();
              stopConfetti();
              launchSubWheel(nextTriggerId, visited);
            }, 1200);
          } else {
            showWinner(subWinner, wc.title || 'Sub-Wheel');
          }
        });
      }, 600);
    }, 100);
  }

  // ── Wheel Toast (inline overlay for trigger wins) ──
  const wheelToast = document.getElementById('wheelToast');
  let toastTimer = null;

  function showToast(name, label) {
    wheelToast.querySelector('.wheel-toast-label').textContent = label || 'Winner';
    wheelToast.querySelector('.wheel-toast-name').textContent = name;
    wheelToast.classList.add('show');
    clearTimeout(toastTimer);
    toastTimer = setTimeout(hideToast, 6000);
  }
  function hideToast() {
    wheelToast.classList.remove('show');
    clearTimeout(toastTimer);
  }
  wheelToast.addEventListener('click', hideToast);

  // ── Winner Modal + Confetti ──
  let modalCb = null;
  function showWinner(name, label, onClose) {
    winnerLabelEl.textContent = label || 'Winner';
    winnerEl.textContent = name;
    modal.classList.add('show');
    modalCb = onClose || null;
    startConfetti();
  }

  closeBtn.addEventListener('click', () => {
    modal.classList.remove('show');
    stopConfetti();
    if (modalCb) { const cb = modalCb; modalCb = null; cb(); }
  });

  // ── Confetti ──
  let confettiTimer = null;
  function startConfetti() {
    stopConfetti();
    const frag = document.createDocumentFragment();
    const vw = window.innerWidth, vh = window.innerHeight;
    for (let i = 0; i < 150; i++) {
      const el = document.createElement('div');
      el.className = 'confetti-piece';
      const x = Math.random()*vw, sy = -20-Math.random()*vh*0.5;
      const ey = vh+40, drift = (Math.random()-0.5)*200, sp = (Math.random()-0.5)*1080;
      const dur = 2+Math.random()*2, delay = Math.random()*0.8;
      el.style.cssText = `left:${x}px;top:${sy}px;width:${6+Math.random()*6}px;height:${10+Math.random()*8}px;background:${COLORS[Math.floor(Math.random()*COLORS.length)]};border-radius:${Math.random()>0.5?'50%':'2px'};animation-duration:${dur}s;animation-delay:${delay}s;`;
      el.animate([
        {transform:'translate(0,0) rotate(0deg)'},
        {transform:`translate(${drift}px,${ey-sy}px) rotate(${sp}deg)`}
      ],{duration:dur*1000,delay:delay*1000,easing:'cubic-bezier(0.25,0,0.5,1)',fill:'forwards'});
      frag.appendChild(el);
    }
    confettiContainer.appendChild(frag);
    confettiTimer = setTimeout(stopConfetti, 5000);
  }
  function stopConfetti() {
    if (confettiTimer) { clearTimeout(confettiTimer); confettiTimer = null; }
    confettiContainer.innerHTML = '';
  }

  // ── Sidebar Actions ──
  shuffleBtn.addEventListener('click', () => {
    const arr = getNames();
    for (let i = arr.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
    textarea.value = arr.join('\n');
    updateNames();
  });
  resetBtn.addEventListener('click', () => { textarea.value = ''; updateNames(); });

  // ══════════════════════════════════════════════════════════════
  // ── SHOP ──
  // ══════════════════════════════════════════════════════════════

  const shopItemsEl = document.getElementById('shopItems');
  const shopEditToggle = document.getElementById('shopEditToggle');
  const shopEditForm = document.getElementById('shopEditForm');
  let shopEditMode = false;

  function ensureShop() { if (!config.shop) config.shop = []; }

  function rebuildShopUI() {
    ensureShop();
    shopItemsEl.innerHTML = '';

    // Show/hide edit button (host only)
    shopEditToggle.style.display = (mp.connected && mp.isHost) ? '' : 'none';

    if (config.shop.length === 0 && !shopEditMode) {
      shopItemsEl.innerHTML = '<div class="shop-empty">No items yet' + (mp.isHost ? ' — click Edit to add some' : '') + '</div>';
      return;
    }

    if (shopEditMode) {
      // Edit mode: show items with delete buttons
      config.shop.forEach((item, idx) => {
        const row = document.createElement('div');
        row.className = 'shop-item-edit-row';
        const nameEl = document.createElement('span');
        nameEl.className = 'shop-item-name';
        nameEl.textContent = item.name;
        row.appendChild(nameEl);

        const costEl = document.createElement('span');
        costEl.className = 'shop-item-cost';
        costEl.textContent = '$' + item.cost;
        row.appendChild(costEl);

        const delBtn = document.createElement('button');
        delBtn.className = 'shop-item-del';
        delBtn.textContent = 'X';
        delBtn.addEventListener('click', () => {
          config.shop.splice(idx, 1);
          saveConfig();
          rebuildShopUI();
        });
        row.appendChild(delBtn);

        shopItemsEl.appendChild(row);
      });
    } else {
      // Player mode: show purchasable buttons
      const me = mp.players.find(p => p.name === mp.playerName);
      const myBalance = me ? me.points : 0;

      config.shop.forEach(item => {
        const btn = document.createElement('button');
        btn.className = 'shop-item-btn';
        btn.disabled = myBalance < item.cost;

        const nameEl = document.createElement('span');
        nameEl.className = 'shop-item-name';
        nameEl.textContent = item.name;
        btn.appendChild(nameEl);

        const actionLabel = document.createElement('span');
        actionLabel.className = 'shop-item-action';
        if (item.action === 'inventory') {
          actionLabel.textContent = 'Goes to inventory';
        } else {
          const wheelTitle = config.wheels[item.wheelId] ? config.wheels[item.wheelId].title : 'Wheel';
          if (item.action === 'add_entry') actionLabel.textContent = 'Add to ' + wheelTitle;
          else if (item.action === 'remove_entry') actionLabel.textContent = 'Remove from ' + wheelTitle;
        }
        btn.appendChild(actionLabel);

        const costEl = document.createElement('span');
        costEl.className = 'shop-item-cost';
        costEl.textContent = '$' + item.cost;
        btn.appendChild(costEl);

        btn.addEventListener('click', () => {
          mp.send({ type: 'shop_purchase', payload: { itemIndex: config.shop.indexOf(item) } });
        });

        shopItemsEl.appendChild(btn);
      });
    }
  }

  shopEditToggle.addEventListener('click', () => {
    shopEditMode = !shopEditMode;
    shopEditToggle.classList.toggle('active', shopEditMode);
    shopEditToggle.textContent = shopEditMode ? 'Done' : 'Edit';
    shopEditForm.classList.toggle('visible', shopEditMode);
    rebuildShopUI();
    // Populate wheel dropdown
    if (shopEditMode) { rebuildShopWheelSelect(); rebuildShopSoundSelect(); }
  });

  function rebuildShopSoundSelect() {
    const sel = document.getElementById('shopNewSound');
    sel.length = 1;
    availableSounds.forEach(f => {
      const opt = document.createElement('option');
      opt.value = f; opt.textContent = f.replace(/\.[^.]+$/, '');
      sel.appendChild(opt);
    });
  }

  document.getElementById('shopSoundPreview').addEventListener('click', () => {
    const sel = document.getElementById('shopNewSound');
    if (sel.value) playSoundFile(sel.value, 1);
  });

  function rebuildShopWheelSelect() {
    const sel = document.getElementById('shopNewWheel');
    sel.innerHTML = '';
    for (const [id, wc] of Object.entries(config.wheels)) {
      const opt = document.createElement('option');
      opt.value = id; opt.textContent = wc.title || id;
      sel.appendChild(opt);
    }
  }

  // Show/hide item type selector based on action
  const shopNewAction = document.getElementById('shopNewAction');
  const shopNewItemType = document.getElementById('shopNewItemType');
  const shopNewWheel = document.getElementById('shopNewWheel');
  shopNewAction.addEventListener('change', () => {
    const isInv = shopNewAction.value === 'inventory';
    shopNewItemType.style.display = isInv ? '' : 'none';
    shopNewWheel.style.display = isInv ? 'none' : '';
  });

  document.getElementById('shopAddBtn').addEventListener('click', () => {
    const name = document.getElementById('shopNewName').value.trim();
    const cost = parseInt(document.getElementById('shopNewCost').value) || 0;
    const action = shopNewAction.value;
    const wheelId = shopNewWheel.value;
    if (!name) return;
    ensureShop();
    const item = { name, cost, action, id: 'shop_' + Date.now() };
    const shopSound = document.getElementById('shopNewSound').value;
    if (shopSound) item.sound = shopSound;
    if (action === 'inventory') {
      item.itemType = shopNewItemType.value;
    } else {
      item.wheelId = wheelId;
    }
    config.shop.push(item);
    document.getElementById('shopNewName').value = '';
    document.getElementById('shopNewCost').value = '';
    saveConfig();
    rebuildShopUI();
  });

  // ══════════════════════════════════════════════════════════════
  // ── LEFT PANEL: INVENTORY + BOOST ──
  // ══════════════════════════════════════════════════════════════

  const leftPanel = document.getElementById('leftPanel');
  const invSlots = document.getElementById('invSlots');

  function getMyInventory() {
    const me = mp.players.find(p => p.name === mp.playerName);
    return me ? (me.inventory || []) : [];
  }

  function rebuildHotbar() {
    const inv = getMyInventory();
    invSlots.innerHTML = '';

    if (inv.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'inv-empty';
      empty.textContent = 'Empty — buy items from the Shop';
      invSlots.appendChild(empty);
    } else {
      // Stack items by itemId
      const stacks = [];
      const stackMap = {};
      inv.forEach(item => {
        const key = item.itemId || item.id;
        if (stackMap[key]) {
          stackMap[key].count++;
          stackMap[key].ids.push(item.id);
        } else {
          const stack = { item, count: 1, ids: [item.id], key };
          stackMap[key] = stack;
          stacks.push(stack);
        }
      });

      stacks.forEach((stack, idx) => {
        const item = stack.item;
        const slot = document.createElement('div');
        slot.className = 'inv-slot';
        slot.dataset.invId = stack.ids[0];

        const canUse = mainWheel.spinning && !isSpinNearEnd();
        if (!canUse) slot.classList.add('disabled');

        const icon = document.createElement('span');
        icon.className = 'inv-icon';
        icon.textContent = item.itemType === 'boost' ? '\u26A1' : '\uD83D\uDCE6';
        slot.appendChild(icon);

        const info = document.createElement('div');
        info.className = 'inv-info';
        const nameEl = document.createElement('div');
        nameEl.className = 'inv-name';
        nameEl.textContent = item.name + (stack.count > 1 ? ' x' + stack.count : '');
        info.appendChild(nameEl);
        const typeEl = document.createElement('div');
        typeEl.className = 'inv-type';
        typeEl.textContent = item.itemType === 'boost' ? 'Wheel Boost' : 'Item';
        info.appendChild(typeEl);
        slot.appendChild(info);

        if (idx < 9) {
          const key = document.createElement('span');
          key.className = 'inv-key';
          key.textContent = (idx + 1).toString();
          slot.appendChild(key);
        }

        slot.addEventListener('click', () => useInventoryItem(stack.ids[0]));
        invSlots.appendChild(slot);
      });
    }

    leftPanel.classList.toggle('visible', mp.connected);
  }

  // Track spin timing to prevent boost in last 0.5s
  let spinStartTime = 0;
  let spinDurationMs = 0;
  let activeBoostOffset = 0;
  let boostTarget = 0;
  let spinEndTime = 0;

  function applyWheelBoost(amount) {
    // Scale boost based on player's local segment sizes vs equal segments
    // If player has boosted entries (making some segments larger), adjust the boost
    const wc = config.wheels[config.activeWheelId];
    if (wc) {
      const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
      const ew = wc.entryWeights || {};
      const numEntries = entries.length;
      if (numEntries > 0) {
        // Calculate player's average segment arc vs equal segment arc
        let totalWeight = 0;
        entries.forEach((name, idx) => {
          const base = ew[name] != null ? ew[name] : 1;
          const idxBoost = ew['__idx_' + idx] || 0;
          totalWeight += base + idxBoost;
        });
        const avgWeight = totalWeight / numEntries;
        const equalWeight = 1; // base weight
        // Scale: if player has larger average weights, boost has less relative impact
        // If weights are equal (avgWeight ~= 1), no scaling
        const scaleFactor = equalWeight / Math.max(0.1, avgWeight);
        amount *= scaleFactor;
      }
    }

    boostTarget += amount;

    // Extend spin duration to give the boost time to take effect
    const now = performance.now();
    const minRemainingTime = 2000; // at least 2 seconds remaining after boost
    const currentRemaining = spinEndTime - now;
    if (currentRemaining < minRemainingTime) {
      const extension = minRemainingTime - currentRemaining;
      spinDurationMs += extension;
      spinEndTime = now + minRemainingTime;
    }
  }

  function isSpinNearEnd() {
    if (!mainWheel.spinning || spinDurationMs === 0) return true;
    const elapsed = performance.now() - spinStartTime;
    return elapsed > spinDurationMs - 500;
  }

  function useInventoryItem(inventoryId) {
    if (!mp.connected) return;
    if (!mainWheel.spinning) return;
    if (isSpinNearEnd()) return;
    mp.send({ type: 'use_item', payload: { inventoryId } });
  }

  // Keyboard shortcuts: 1-9 for inventory slots (uses stacked slots)
  document.addEventListener('keydown', (e) => {
    const num = parseInt(e.key);
    if (num >= 1 && num <= 9) {
      const slots = invSlots.querySelectorAll('.inv-slot');
      const slot = slots[num - 1];
      if (slot && slot.dataset.invId) useInventoryItem(slot.dataset.invId);
    }
  });

  // Periodically refresh inventory enabled/disabled state during spin
  let hotbarRefreshInterval = null;
  function startHotbarRefresh() {
    if (hotbarRefreshInterval) return;
    hotbarRefreshInterval = setInterval(() => {
      const slots = invSlots.querySelectorAll('.inv-slot');
      const canUse = mainWheel.spinning && !isSpinNearEnd();
      slots.forEach(s => s.classList.toggle('disabled', !canUse));
      if (!mainWheel.spinning) {
        clearInterval(hotbarRefreshInterval);
        hotbarRefreshInterval = null;
        slots.forEach(s => s.classList.add('disabled'));
      }
    }, 100);
  }

  // ── Left panel: Chance Enhancer (boost) ──
  const lpBoostEntry = document.getElementById('lpBoostEntry');
  const lpBoostSlider = document.getElementById('lpBoostSlider');
  const lpBoostMax = document.getElementById('lpBoostMax');
  const lpBoostCost = document.getElementById('lpBoostCost');
  const lpBoostImpact = document.getElementById('lpBoostImpact');
  const lpBoostBtn = document.getElementById('lpBoostBtn');
  const lpBoostStatus = document.getElementById('lpBoostStatus');

  function refreshBoostPanel() {
    // Populate entry dropdown from active wheel (using index as value)
    const wc = config.wheels[config.activeWheelId];
    lpBoostEntry.innerHTML = '<option value="">Pick entry...</option>';
    if (wc) {
      const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
      const seen = {};
      entries.forEach((e, idx) => {
        seen[e] = (seen[e] || 0) + 1;
        const opt = document.createElement('option');
        opt.value = idx;
        opt.textContent = seen[e] > 1 ? e + ' (#' + seen[e] + ')' : e;
        opt.dataset.entryName = e;
        lpBoostEntry.appendChild(opt);
      });
    }
    // Set max to player's balance
    const me = mp.players.find(p => p.name === mp.playerName);
    const balance = me ? me.points : 0;
    lpBoostSlider.max = balance;
    lpBoostMax.textContent = '$' + balance;
    lpBoostSlider.value = 0;
    lpBoostCost.textContent = '$0';
    lpBoostImpact.textContent = '+0%';
    lpBoostStatus.textContent = '';
    lpBoostBtn.disabled = false;
  }

  lpBoostSlider.addEventListener('input', () => {
    const cost = parseInt(lpBoostSlider.value) || 0;
    lpBoostCost.textContent = '$' + cost;
    const selectedIdx = lpBoostEntry.value;
    if (selectedIdx === '' || cost === 0) { lpBoostImpact.textContent = '+0%'; return; }
    const idx = parseInt(selectedIdx);
    const wc = config.wheels[config.activeWheelId];
    if (!wc) return;
    const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
    if (idx >= entries.length) return;
    let totalWeight = 0;
    const ew = wc.entryWeights || {};
    entries.forEach((e, i) => {
      let w = ew[e] != null ? ew[e] : 1;
      const idxBoost = ew['__idx_' + i] || 0;
      totalWeight += w + idxBoost;
    });
    const entryName = entries[idx];
    const baseW = ew[entryName] != null ? ew[entryName] : 1;
    const existingBoost = ew['__idx_' + idx] || 0;
    const entryWeight = baseW + existingBoost;
    if (totalWeight === 0) return;
    const addedWeight = cost * 0.1;
    const oldChance = (entryWeight / totalWeight) * 100;
    const newChance = ((entryWeight + addedWeight) / (totalWeight + addedWeight)) * 100;
    const delta = newChance - oldChance;
    lpBoostImpact.textContent = `${oldChance.toFixed(1)}% \u2192 ${newChance.toFixed(1)}% (+${delta.toFixed(1)}%)`;
  });

  lpBoostEntry.addEventListener('change', () => {
    lpBoostSlider.dispatchEvent(new Event('input'));
  });

  lpBoostBtn.addEventListener('click', () => {
    const selectedIdx = lpBoostEntry.value;
    const cost = parseInt(lpBoostSlider.value) || 0;
    if (selectedIdx === '') { lpBoostStatus.textContent = 'Pick an entry'; return; }
    if (cost <= 0) { lpBoostStatus.textContent = 'Slide to set amount'; return; }
    const idx = parseInt(selectedIdx);
    const wc = config.wheels[config.activeWheelId];
    const entries = wc ? (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean) : [];
    const entryName = entries[idx] || '';
    mp.send({ type: 'boost', payload: { entry: entryName, entryIndex: idx, amount: cost, wheelId: config.activeWheelId } });
    lpBoostBtn.disabled = true;
    lpBoostStatus.textContent = `Boosting "${entryName}" for $${cost}`;
  });

  // ══════════════════════════════════════════════════════════════
  // ── STOCK MARKET ──
  // ══════════════════════════════════════════════════════════════

  let currentStockPrices = {};  // { name: { price, prevPrice, change, history } }
  let currentPortfolios = {};   // { playerName: { entryName: shares } }
  let currentCostBases = {};    // { playerName: { entryName: { totalCost, shares } } }
  // Note: Server now sends personalized targetAngles, so we don't need to save/restore weights

  function drawSparkline(canvas, history) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0, 0, w, h);
    if (history.length < 2) return;
    const min = Math.min(...history), max = Math.max(...history);
    const range = max - min || 1;
    ctx.beginPath();
    history.forEach((val, i) => {
      const x = (i / (history.length - 1)) * w;
      const y = h - ((val - min) / range) * (h - 2) - 1;
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    ctx.strokeStyle = history[history.length - 1] >= history[0] ? '#47B04B' : '#E74856';
    ctx.lineWidth = 1.5;
    ctx.stroke();
  }

  // Store chart data for hover lookups
  let currentChartData = { history: [], padding: {}, chartW: 0, chartH: 0, min: 0, max: 0, canvasW: 0, canvasH: 0 };

  function drawLargeChart(canvas, history) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const padding = { top: 20, right: 20, bottom: 30, left: 55 };
    const chartW = w - padding.left - padding.right;
    const chartH = h - padding.top - padding.bottom;

    // Store for hover calculations
    currentChartData = { history: history || [], padding, chartW, chartH, min: 0, max: 0, canvasW: w, canvasH: h };

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(0, 0, w, h);

    if (!history || history.length < 2) {
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = '14px Nunito';
      ctx.textAlign = 'center';
      ctx.fillText('Not enough data', w / 2, h / 2);
      return;
    }

    const min = Math.min(...history), max = Math.max(...history);
    const range = max - min || 1;
    currentChartData.min = min;
    currentChartData.max = max;

    // Draw grid lines
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= 5; i++) {
      const y = padding.top + (chartH / 5) * i;
      ctx.beginPath();
      ctx.moveTo(padding.left, y);
      ctx.lineTo(w - padding.right, y);
      ctx.stroke();

      // Price labels
      const priceVal = max - (range / 5) * i;
      ctx.fillStyle = 'rgba(255,255,255,0.6)';
      ctx.font = '11px Nunito';
      ctx.textAlign = 'right';
      ctx.fillText('$' + priceVal.toFixed(2), padding.left - 8, y + 4);
    }

    // Draw price line with points
    const points = [];
    ctx.beginPath();
    history.forEach((val, i) => {
      const x = padding.left + (i / (history.length - 1)) * chartW;
      const y = padding.top + chartH - ((val - min) / range) * chartH;
      points.push({ x, y, value: val, index: i });
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    });
    const isUp = history[history.length - 1] >= history[0];
    ctx.strokeStyle = isUp ? '#47B04B' : '#E74856';
    ctx.lineWidth = 2.5;
    ctx.stroke();

    // Fill area under line
    ctx.lineTo(padding.left + chartW, padding.top + chartH);
    ctx.lineTo(padding.left, padding.top + chartH);
    ctx.closePath();
    ctx.fillStyle = isUp ? 'rgba(71,176,75,0.2)' : 'rgba(231,72,86,0.2)';
    ctx.fill();

    // Draw data points
    points.forEach((pt, i) => {
      ctx.beginPath();
      ctx.arc(pt.x, pt.y, 3, 0, Math.PI * 2);
      ctx.fillStyle = isUp ? '#47B04B' : '#E74856';
      ctx.fill();
    });

    // Time labels
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '11px Nunito';
    ctx.textAlign = 'center';
    ctx.fillText('oldest', padding.left + 20, h - 8);
    ctx.fillText('newest', w - padding.right - 20, h - 8);
    if (history.length > 2) {
      ctx.fillText(`${history.length} ticks`, w / 2, h - 8);
    }
  }

  // Chart hover functionality
  function setupChartHover() {
    const canvas = document.getElementById('stockDetailChart');
    const tooltip = document.getElementById('chartTooltip');
    if (!canvas || !tooltip) return;

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top) * scaleY;

      const { history, padding, chartW, chartH, min, max } = currentChartData;
      if (!history || history.length < 2) {
        tooltip.style.display = 'none';
        return;
      }

      // Check if mouse is in chart area
      if (x < padding.left || x > padding.left + chartW || y < padding.top || y > padding.top + chartH) {
        tooltip.style.display = 'none';
        return;
      }

      // Find closest data point
      const relX = x - padding.left;
      const dataIndex = Math.round((relX / chartW) * (history.length - 1));
      const clampedIndex = Math.max(0, Math.min(history.length - 1, dataIndex));
      const price = history[clampedIndex];
      const ticksAgo = history.length - 1 - clampedIndex;

      // Position tooltip
      const tooltipX = (e.clientX - rect.left) + 15;
      const tooltipY = (e.clientY - rect.top) - 10;
      tooltip.style.left = tooltipX + 'px';
      tooltip.style.top = tooltipY + 'px';
      tooltip.style.display = 'block';
      tooltip.innerHTML = `<strong>$${price.toFixed(2)}</strong><br><span style="color:var(--text-muted);font-size:0.75rem;">${ticksAgo === 0 ? 'current' : ticksAgo + ' ticks ago'}</span>`;
    });

    canvas.addEventListener('mouseleave', () => {
      tooltip.style.display = 'none';
    });
  }

  let selectedStock = null;
  let currentOrderType = 'market'; // Preserve order type selection across rebuilds
  let currentLimitPrice = null;
  let currentShareCount = 1;

  function selectStock(name) {
    selectedStock = name;
    const stock = currentStockPrices[name];
    const detail = document.getElementById('stockDetail');
    const stockList = document.getElementById('stockList');
    const myPortfolio = currentPortfolios[mp.playerName] || {};
    const myShares = myPortfolio[name] || 0;

    // Highlight selected in list
    stockList.querySelectorAll('.stock-row').forEach(r => r.classList.remove('selected'));
    const selectedRow = stockList.querySelector('.stock-row[data-name="' + name + '"]');
    if (selectedRow) selectedRow.classList.add('selected');

    // Show detail panel
    detail.style.display = 'block';
    const nameEl = document.getElementById('stockDetailName');
    nameEl.innerHTML = `
      <h3 style="margin:0 0 8px 0;font-size:1.3rem;">${name}</h3>
      <span class="stock-price" style="font-size:1.2rem;">$${stock.price.toFixed(2)}</span>
      <span class="stock-change ${stock.change > 0 ? 'up' : stock.change < 0 ? 'down' : 'flat'}" style="font-size:0.9rem;margin-left:8px;">
        ${stock.change >= 0 ? '+' : ''}${stock.change.toFixed(1)}%
      </span>
      ${myShares > 0 ? `<div style="margin-top:8px;font-size:0.85rem;color:var(--text-muted);">You own <strong>${myShares}</strong> shares (worth <span style="color:#F5A623;">$${(myShares * stock.price).toFixed(2)}</span>)</div>` : ''}
    `;

    // Draw large chart - resize canvas responsively
    const canvas = document.getElementById('stockDetailChart');
    const chartContainer = canvas.parentElement;
    const containerRect = chartContainer.getBoundingClientRect();
    const vw = window.innerWidth;
    // Responsive chart sizes
    let chartW = 500, chartH = 280;
    if (vw <= 600) { chartW = Math.min(containerRect.width - 20, 320); chartH = 150; }
    else if (vw <= 900) { chartW = Math.min(containerRect.width - 20, 400); chartH = 180; }
    else { chartW = Math.min(containerRect.width - 20, 500); chartH = 280; }
    canvas.width = chartW;
    canvas.height = chartH;
    canvas.style.width = chartW + 'px';
    canvas.style.height = chartH + 'px';
    drawLargeChart(canvas, stock.history);

    // Trade controls - preserve current selections
    const tradeEl = document.getElementById('stockDetailTrade');
    const isLimit = currentOrderType === 'limit';
    const limitVal = currentLimitPrice || stock.price.toFixed(2);
    tradeEl.innerHTML = `
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px;">
        <input type="number" id="detailShareInput" min="1" value="${currentShareCount}" placeholder="#" style="width:60px;">
        <span id="detailCostPreview" style="font-size:0.85rem;color:var(--text-muted);">= $${(stock.price * currentShareCount).toFixed(2)}</span>
      </div>
      <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:10px;">
        <label style="font-size:0.8rem;color:var(--text-muted);">
          <input type="radio" name="orderType" value="market" ${!isLimit ? 'checked' : ''}> Market
        </label>
        <label style="font-size:0.8rem;color:var(--text-muted);">
          <input type="radio" name="orderType" value="limit" ${isLimit ? 'checked' : ''}> Limit
        </label>
        <input type="number" id="detailLimitPrice" placeholder="Limit $" step="0.01" value="${limitVal}" style="width:80px;display:${isLimit ? 'block' : 'none'};">
      </div>
      <div style="display:flex;gap:8px;">
        <button class="stock-buy" id="detailBuyBtn">Buy</button>
        <button class="stock-sell" id="detailSellBtn" ${myShares <= 0 ? 'disabled' : ''}>Sell</button>
      </div>
      <div id="pendingOrdersArea" style="margin-top:12px;font-size:0.8rem;"></div>
    `;

    const shareInput = document.getElementById('detailShareInput');
    const costPreview = document.getElementById('detailCostPreview');
    const limitPriceInput = document.getElementById('detailLimitPrice');
    const orderTypeRadios = tradeEl.querySelectorAll('input[name="orderType"]');

    // Show/hide limit price input and persist selection
    orderTypeRadios.forEach(radio => {
      radio.addEventListener('change', () => {
        currentOrderType = tradeEl.querySelector('input[name="orderType"]:checked').value;
        const showLimit = currentOrderType === 'limit';
        limitPriceInput.style.display = showLimit ? 'block' : 'none';
        if (showLimit && !limitPriceInput.value) {
          limitPriceInput.value = stock.price.toFixed(2);
        }
      });
    });

    // Persist limit price
    limitPriceInput.addEventListener('input', () => {
      currentLimitPrice = limitPriceInput.value;
    });

    // Persist share count
    shareInput.addEventListener('input', () => {
      const s = parseInt(shareInput.value) || 1;
      currentShareCount = s;
      costPreview.textContent = '= $' + (stock.price * s).toFixed(2);
    });

    document.getElementById('detailBuyBtn').addEventListener('click', () => {
      const shares = parseInt(shareInput.value) || 1;
      const orderType = tradeEl.querySelector('input[name="orderType"]:checked').value;
      const limitPrice = orderType === 'limit' ? parseFloat(limitPriceInput.value) : null;
      mp.send({ type: 'buy_stock', payload: { entryName: name, shares, orderType, limitPrice } });
    });

    document.getElementById('detailSellBtn').addEventListener('click', () => {
      const shares = Math.min(parseInt(shareInput.value) || 1, myShares);
      const orderType = tradeEl.querySelector('input[name="orderType"]:checked').value;
      const limitPrice = orderType === 'limit' ? parseFloat(limitPriceInput.value) : null;
      mp.send({ type: 'sell_stock', payload: { entryName: name, shares, orderType, limitPrice } });
    });
  }

  function rebuildMarketUI() {
    const stockList = document.getElementById('stockList');
    const stockDetail = document.getElementById('stockDetail');
    if (!stockList) return;
    stockList.innerHTML = '';
    if (stockDetail) stockDetail.style.display = 'none';

    const myPortfolio = currentPortfolios[mp.playerName] || {};
    const names = Object.keys(currentStockPrices).sort();

    if (names.length === 0) {
      stockList.innerHTML = '<div style="padding:20px;text-align:center;color:var(--text-muted);">No stocks yet. Spin the wheel to start the market.</div>';
      return;
    }

    let totalPortfolioValue = 0;
    names.forEach(name => {
      const stock = currentStockPrices[name];
      const myShares = myPortfolio[name] || 0;
      const holdingValue = myShares * stock.price;
      totalPortfolioValue += holdingValue;

      const row = document.createElement('div');
      row.className = 'stock-row';
      row.setAttribute('data-name', name);

      // Click to select
      row.addEventListener('click', () => selectStock(name));

      // Header line: name, sparkline, price, change
      const header = document.createElement('div');
      header.className = 'stock-header';

      const nameEl = document.createElement('span');
      nameEl.className = 'stock-name';
      nameEl.textContent = name;
      header.appendChild(nameEl);

      if (stock.history && stock.history.length > 1) {
        const spark = document.createElement('canvas');
        spark.className = 'stock-sparkline';
        spark.width = 120; spark.height = 40;
        drawSparkline(spark, stock.history);
        header.appendChild(spark);
      }

      const priceEl = document.createElement('span');
      priceEl.className = 'stock-price';
      priceEl.textContent = '$' + stock.price.toFixed(2);
      header.appendChild(priceEl);

      const changeEl = document.createElement('span');
      changeEl.className = 'stock-change ' + (stock.change > 0 ? 'up' : stock.change < 0 ? 'down' : 'flat');
      changeEl.textContent = (stock.change >= 0 ? '+' : '') + stock.change.toFixed(1) + '%';
      header.appendChild(changeEl);

      row.appendChild(header);

      // Holdings info (compact)
      if (myShares > 0) {
        const holdEl = document.createElement('div');
        holdEl.className = 'stock-holdings';
        holdEl.innerHTML = '<strong>' + myShares + '</strong> shares (<span class="stock-portfolio-value">$' + holdingValue.toFixed(2) + '</span>)';
        row.appendChild(holdEl);
      }

      stockList.appendChild(row);
    });

    // Auto-select first stock if none selected
    if (names.length > 0 && (!selectedStock || !currentStockPrices[selectedStock])) {
      selectStock(names[0]);
    } else if (selectedStock && currentStockPrices[selectedStock]) {
      selectStock(selectedStock);
    }

    const statusEl = document.getElementById('marketStatus');
    if (statusEl) {
      statusEl.textContent = '$' + totalPortfolioValue.toFixed(0) + ' portfolio';
    }

    // Render positions panel
    renderPositionsPanel();
  }

  function renderPositionsPanel() {
    const positionsList = document.getElementById('positionsList');
    if (!positionsList) return;

    const myPortfolio = currentPortfolios[mp.playerName] || {};
    const myCostBasis = currentCostBases[mp.playerName] || {};
    const holdings = Object.keys(myPortfolio).filter(name => myPortfolio[name] > 0);

    if (holdings.length === 0) {
      positionsList.innerHTML = '<div style="color:var(--text-muted);font-size:0.85rem;padding:8px 0;">No positions yet.<br>Buy some stocks to get started!</div>';
      return;
    }

    let totalValue = 0;
    let totalCost = 0;

    positionsList.innerHTML = holdings.map(name => {
      const shares = myPortfolio[name];
      const stock = currentStockPrices[name];
      const price = stock ? stock.price : 0;
      const currentValue = shares * price;
      totalValue += currentValue;

      const cb = myCostBasis[name];
      let avgCost = 0;
      let costBasisTotal = 0;
      let profitLoss = 0;
      let profitLossPct = 0;

      if (cb && cb.shares > 0) {
        avgCost = cb.totalCost / cb.shares;
        costBasisTotal = cb.totalCost;
        totalCost += costBasisTotal;
        profitLoss = currentValue - costBasisTotal;
        profitLossPct = costBasisTotal > 0 ? (profitLoss / costBasisTotal) * 100 : 0;
      }

      const isProfit = profitLoss >= 0;
      const plClass = isProfit ? 'up' : 'down';
      const plSign = isProfit ? '+' : '';

      return `
        <div class="position-item" style="background:rgba(255,255,255,0.03);border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer;" onclick="selectStock('${name}')">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
            <span style="font-weight:600;font-size:0.9rem;">${name}</span>
            <span style="font-size:0.85rem;color:var(--text-muted);">${shares} shares</span>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center;font-size:0.8rem;">
            <span style="color:var(--text-muted);">Avg: $${avgCost.toFixed(2)}</span>
            <span style="color:var(--text-muted);">Val: $${currentValue.toFixed(0)}</span>
          </div>
          ${cb ? `
          <div style="display:flex;justify-content:space-between;align-items:center;font-size:0.8rem;margin-top:4px;">
            <span style="color:var(--text-muted);">P/L:</span>
            <span class="stock-change ${plClass}">${plSign}$${profitLoss.toFixed(0)} (${plSign}${profitLossPct.toFixed(1)}%)</span>
          </div>
          ` : ''}
        </div>
      `;
    }).join('');

    // Add summary at bottom
    const totalPL = totalValue - totalCost;
    const totalPLPct = totalCost > 0 ? (totalPL / totalCost) * 100 : 0;
    const isTotalProfit = totalPL >= 0;

    positionsList.innerHTML += `
      <div style="border-top:1px solid rgba(255,255,255,0.1);margin-top:8px;padding-top:8px;">
        <div style="display:flex;justify-content:space-between;font-size:0.85rem;font-weight:600;">
          <span>Total Value:</span>
          <span>$${totalValue.toFixed(0)}</span>
        </div>
        ${totalCost > 0 ? `
        <div style="display:flex;justify-content:space-between;font-size:0.8rem;margin-top:4px;">
          <span style="color:var(--text-muted);">Total P/L:</span>
          <span class="stock-change ${isTotalProfit ? 'up' : 'down'}">${isTotalProfit ? '+' : ''}$${totalPL.toFixed(0)} (${isTotalProfit ? '+' : ''}${totalPLPct.toFixed(1)}%)</span>
        </div>
        ` : ''}
      </div>
    `;
  }

  // ── Orders UI ──
  let currentPendingOrders = [];
  let currentOrderHistory = [];

  function renderOrdersUI(pending, history) {
    currentPendingOrders = pending || [];
    currentOrderHistory = history || [];

    const pendingPanel = document.getElementById('pendingOrdersPanel');
    const historyPanel = document.getElementById('orderHistoryPanel');

    if (!pendingPanel || !historyPanel) return;

    // Render pending orders
    if (currentPendingOrders.length === 0) {
      pendingPanel.innerHTML = '<div class="order-empty">No pending orders</div>';
    } else {
      pendingPanel.innerHTML = currentPendingOrders.map(order => `
        <div class="order-item">
          <span class="order-type ${order.isBuy ? 'buy' : 'sell'}">${order.isBuy ? 'BUY' : 'SELL'}</span>
          <span class="order-stock">${order.entryName}</span>
          <span class="order-shares">${order.filledShares}/${order.totalShares}</span>
          ${order.orderType === 'limit' ? `<span class="order-price">@ $${order.limitPrice.toFixed(2)}</span>` : '<span class="order-price">Market</span>'}
          <span class="order-status ${order.status}">${order.status}</span>
          <button class="order-cancel" onclick="cancelOrder('${order.id}')">Cancel</button>
        </div>
      `).join('');
    }

    // Render order history
    if (currentOrderHistory.length === 0) {
      historyPanel.innerHTML = '<div class="order-empty">No order history</div>';
    } else {
      historyPanel.innerHTML = currentOrderHistory.map(order => {
        const avgPrice = order.fills.length > 0
          ? order.fills.reduce((sum, f) => sum + f.price * f.shares, 0) / order.filledShares
          : 0;
        return `
          <div class="order-item">
            <span class="order-type ${order.isBuy ? 'buy' : 'sell'}">${order.isBuy ? 'BUY' : 'SELL'}</span>
            <span class="order-stock">${order.entryName}</span>
            <span class="order-shares">${order.filledShares}/${order.totalShares}</span>
            <span class="order-price">@ $${avgPrice.toFixed(2)}</span>
            <span class="order-status ${order.status}">${order.status}</span>
          </div>
        `;
      }).join('');
    }
  }

  // Order tab switching
  document.querySelectorAll('.order-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.order-tab').forEach(t => t.classList.remove('active'));
      tab.classList.add('active');
      const tabName = tab.dataset.tab;
      document.getElementById('pendingOrdersPanel').style.display = tabName === 'pending' ? 'block' : 'none';
      document.getElementById('orderHistoryPanel').style.display = tabName === 'history' ? 'block' : 'none';
    });
  });

  // Global cancel order function
  window.cancelOrder = function(orderId) {
    mp.send({ type: 'cancel_order', payload: { orderId } });
  };

  // Global selectStock function (for position panel clicks)
  window.selectStock = selectStock;

  // Initialize chart hover functionality
  setupChartHover();

  // ══════════════════════════════════════════════════════════════
  // ── MULTIPLAYER ──
  // ══════════════════════════════════════════════════════════════

  // ── Connection UI ──
  const connOverlay = document.getElementById('connectionOverlay');
  const connError = document.getElementById('connError');
  const statusBar = document.getElementById('statusBar');
  const statusDot = document.getElementById('statusDot');
  const statusName = document.getElementById('statusName');
  const statusHostBadge = document.getElementById('statusHostBadge');
  const statusText = document.getElementById('statusText');
  const spinInitiator = document.getElementById('spinInitiator');

  // Tab switching for connection overlay
  document.querySelectorAll('.conn-tabs button').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.conn-tabs button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('hostForm').classList.toggle('active', btn.dataset.mode === 'host');
      document.getElementById('joinForm').classList.toggle('active', btn.dataset.mode === 'join');
      connError.textContent = '';
    });
  });

  document.getElementById('startHostBtn').addEventListener('click', () => {
    const name = document.getElementById('hostNameInput').value.trim();
    if (!name) { connError.textContent = 'Please enter your name'; return; }
    const port = parseInt(document.getElementById('portInput').value) || 8080;
    // Connect to self (server must already be running)
    connectToServer('localhost', port, name);
  });

  document.getElementById('connectBtn').addEventListener('click', () => {
    const name = document.getElementById('joinNameInput').value.trim();
    if (!name) { connError.textContent = 'Please enter your name'; return; }
    const addr = document.getElementById('joinAddress').value.trim();
    if (!addr) { connError.textContent = 'Please enter the server address'; return; }
    const parts = addr.split(':');
    const host = parts[0];
    const port = parseInt(parts[1]) || 8080;
    connectToServer(host, port, name);
  });

  document.getElementById('disconnectBtn').addEventListener('click', () => {
    if (mp.ws) mp.ws.close();
    mp.connected = false;
    mp.ws = null;
    mp.reconnectAttempts = mp.maxReconnect; // prevent auto-reconnect
    showConnectionScreen();
  });

  function connectToServer(host, port, name) {
    connError.textContent = '';
    mp.lastHost = host;
    mp.lastPort = port;
    mp.playerName = name;

    const btns = connOverlay.querySelectorAll('.conn-submit');
    btns.forEach(b => b.disabled = true);

    try {
      mp.ws = new WebSocket(`ws://${host}:${port}`);
    } catch(e) {
      connError.textContent = 'Invalid address';
      btns.forEach(b => b.disabled = false);
      return;
    }

    mp.ws.onopen = () => {
      mp.reconnectAttempts = 0;
      mp.send({ type: 'join', payload: { name } });
    };

    mp.ws.onmessage = (e) => {
      let msg;
      try { msg = JSON.parse(e.data); } catch { return; }
      handleServerMessage(msg);
    };

    mp.ws.onerror = () => {
      connError.textContent = 'Connection failed';
      btns.forEach(b => b.disabled = false);
    };

    mp.ws.onclose = () => {
      const wasConnected = mp.connected;
      mp.connected = false;
      btns.forEach(b => b.disabled = false);

      if (wasConnected) {
        statusDot.className = 'status-dot disconnected';
        statusText.textContent = 'Disconnected';
        // Try reconnect
        if (mp.reconnectAttempts < mp.maxReconnect) {
          mp.reconnectAttempts++;
          statusText.textContent = `Reconnecting (${mp.reconnectAttempts})...`;
          statusDot.className = 'status-dot connecting';
          setTimeout(() => connectToServer(mp.lastHost, mp.lastPort, mp.playerName), 2000 * mp.reconnectAttempts);
        } else {
          showConnectionScreen();
        }
      }
    };
  }

  function showConnectionScreen() {
    connOverlay.classList.remove('hidden');
    statusBar.classList.remove('visible');
    leftPanel.classList.remove('visible');
    readyBar.classList.remove('visible');
    updateConfigLock();
  }

  function hideConnectionScreen() {
    connOverlay.classList.add('hidden');
    statusBar.classList.add('visible');
  }

  // ── Server message handler ──
  function handleServerMessage(msg) {
    switch (msg.type) {
      case 'joined': {
        const p = msg.payload;
        mp.connected = true;
        mp.clientId = p.clientId;
        mp.isHost = p.isHost;
        mp.playerName = p.name;
        mp.players = p.players || [];

        // Apply remote config if we're joining an existing room
        if (p.config) {
          config = JSON.parse(JSON.stringify(p.config));
          selectedWheelId = config.activeWheelId;
          rebuildWheelSelector();
          const wc = selectedWheelConfig();
          textarea.value = wc ? wc.entries || '' : '';
          if (wc) syncWheelConfig(mainWheel, wc);
          mainWheel.names = getNames();
          mainWheel.cooldowns.clear();
          mainWheel.rotation = 0;
          mainWheel.invalidateLayout();
          mainWheel.draw();
          countEl.textContent = mainWheel.names.length;
          rebuildConfigUI();
        }

        hideConnectionScreen();
        statusDot.className = 'status-dot';
        statusName.textContent = mp.playerName;
        statusHostBadge.style.display = mp.isHost ? '' : 'none';
        statusText.textContent = `${mp.players.filter(p => p.connected).length} player(s)`;

        updatePlayerListUI();
        updateConfigLock();
        rebuildShopUI();
        rebuildHotbar();
        readyBar.classList.add('visible');
        refreshBoostPanel();
        if (betHint) betHint.style.display = '';
        mainWheel.canvas.style.cursor = 'pointer';

        // Host pushes initial config to server so joiners get it
        if (mp.isHost) {
          const wc = selectedWheelConfig();
          if (wc) wc.entries = textarea.value;
          mp.send({ type: 'config_update', payload: { config } });
        }
        break;
      }

      case 'host_promoted': {
        mp.isHost = true;
        statusHostBadge.style.display = '';
        updateConfigLock();
        break;
      }

      case 'config_synced': {
        if (mp.isHost) {
          // Host already has the authoritative config; just redraw
          const wcH = selectedWheelConfig();
          if (wcH) syncWheelConfig(mainWheel, wcH);
          mainWheel.invalidateLayout();
          mainWheel.draw();
          refreshBoostPanel();
          break;
        }
        // Non-host: apply full config (entryWeights are stripped by server)
        config = JSON.parse(JSON.stringify(msg.payload.config));
        selectedWheelId = config.activeWheelId;
        rebuildWheelSelector();
        const wc = selectedWheelConfig();
        textarea.value = wc ? wc.entries || '' : '';
        if (wc) syncWheelConfig(mainWheel, wc);
        mainWheel.names = getNames();
        mainWheel.cooldowns.clear();
        mainWheel.rotation = 0;
        mainWheel.invalidateLayout();
        mainWheel.draw();
        countEl.textContent = mainWheel.names.length;
        rebuildConfigUI();
        rebuildShopUI();
        refreshBoostPanel();
        break;
      }

      case 'players_sync': {
        mp.players = msg.payload.players || [];
        statusText.textContent = `${mp.players.filter(p => p.connected).length} player(s)`;
        updatePlayerListUI();
        rebuildShopUI();
        rebuildHotbar();
        break;
      }

      case 'points_update': {
        // Update local player list
        const pu = msg.payload;
        const pl = mp.players.find(p => p.name === pu.name);
        if (pl) pl.points = pu.points;
        updatePlayerListUI();
        break;
      }

      case 'ready_phase': {
        readyNames = new Set();
        showReadyPhase(msg.payload.wheelId);
        break;
      }

      case 'player_ready': {
        readyNames.add(msg.payload.name);
        updateReadyBarChips();
        break;
      }

      case 'countdown_update': {
        if (msg.payload.seconds <= 5 && !countdownSoundPlayed) {
          countdownSoundPlayed = true;
          playSoundFile('54321countdown.mp3', 1);
        }
        startClientCountdown(msg.payload.seconds);
        break;
      }

      case 'bet_placed': {
        break;
      }

      case 'bets_sync': {
        allBets = msg.payload.bets || [];
        mainWheel.draw();
        break;
      }

      case 'boost_applied': {
        // Only the boosting player receives this — apply weight locally for visual
        const ba = msg.payload;
        const wc2 = config.wheels[config.activeWheelId];
        if (wc2) {
          if (!wc2.entryWeights) wc2.entryWeights = {};
          const key = ba.weightKey || ba.entry;
          const current = wc2.entryWeights[key] || 0;
          wc2.entryWeights[key] = current + ba.addedWeight;
          syncWheelConfig(mainWheel, wc2);
          mainWheel.invalidateLayout();
          mainWheel.draw();
        }
        refreshBoostPanel();
        break;
      }

      case 'boost_notification': {
        // Someone else boosted — show toast without weight info
        const bn = msg.payload;
        showToast(bn.name + ' boosted "' + bn.entry + '" for $' + bn.cost, 'BOOST');
        setTimeout(hideToast, 2000);
        break;
      }

      case 'boost_reverted': {
        // Our personal boost was reverted after spin
        const br = msg.payload;
        const wc3 = config.wheels[config.activeWheelId];
        if (wc3 && wc3.entryWeights) {
          const key = br.weightKey;
          if (wc3.entryWeights[key] != null) {
            wc3.entryWeights[key] -= br.amount;
            if (Math.abs(wc3.entryWeights[key]) < 0.001) delete wc3.entryWeights[key];
          }
          syncWheelConfig(mainWheel, wc3);
          mainWheel.invalidateLayout();
          mainWheel.draw();
        }
        refreshBoostPanel();
        break;
      }

      case 'inventory_update': {
        const iu = msg.payload;
        const pl2 = mp.players.find(p => p.name === iu.name);
        if (pl2) pl2.inventory = iu.inventory;
        if (iu.name === mp.playerName) rebuildHotbar();
        break;
      }

      case 'item_used': {
        const iu2 = msg.payload;
        if (iu2.itemType === 'boost' && mainWheel.spinning) {
          applyWheelBoost(iu2.boostAmount);
        }
        // Flash message
        showToast(iu2.name + ' used ' + iu2.itemName + '!', 'BOOST');
        setTimeout(hideToast, 1500);
        // Rebuild hotbar if it was us
        if (iu2.name === mp.playerName) rebuildHotbar();
        break;
      }

      case 'spin_start': {
        hideReadyPhase();
        handleRemoteSpin(msg.payload);
        break;
      }

      case 'spin_finished': {
        handleSpinFinished(msg.payload);
        allBets = []; // clear bet chips from wheel
        if (msg.payload.betResults && msg.payload.betResults.length > 0) {
          showBetResults(msg.payload.betResults);
        }
        break;
      }

      case 'stock_prices': {
        currentStockPrices = msg.payload.prices || {};
        currentPortfolios = msg.payload.portfolios || {};
        currentCostBases = msg.payload.costBases || {};
        rebuildMarketUI();
        break;
      }

      case 'stock_trade_result': {
        const tr = msg.payload;
        if (tr.success) {
          // Order placed, not yet filled
          if (tr.action === 'buy_order' || tr.action === 'sell_order') {
            showToast(tr.message, 'ORDER');
            // Update orders UI immediately with new pending order
            if (tr.pendingOrders || tr.orderHistory) {
              renderOrdersUI(tr.pendingOrders || [], tr.orderHistory || []);
            }
          } else {
            // Legacy instant trades
            showToast((tr.action === 'buy' ? 'Bought' : 'Sold') + ' ' + tr.shares + ' ' + tr.entryName + ' for $' + tr.totalCost, 'TRADE');
          }
        } else {
          showToast(tr.message || 'Trade failed', 'ERROR');
        }
        setTimeout(hideToast, 2000);
        break;
      }

      case 'order_update': {
        const ou = msg.payload;
        // Play sound on fill
        if (ou.status === 'filled' || ou.status === 'partial') {
          playSoundFile('chipsplaced.mp3', 0.5);
        }
        // Show notification
        if (ou.status === 'filled') {
          showToast(`Order filled: ${ou.isBuy ? 'Bought' : 'Sold'} ${ou.filledShares}x ${ou.entryName}`, 'FILLED');
        } else if (ou.status === 'partial') {
          const fill = ou.lastFill;
          if (fill) {
            showToast(`Partial fill: ${fill.shares}x ${ou.entryName} @ $${fill.price.toFixed(2)}`, 'FILL');
          }
        } else if (ou.status === 'cancelled') {
          showToast(`Order cancelled: ${ou.message}`, 'ERROR');
        }
        setTimeout(hideToast, 1500);
        // Update orders UI if present
        if (ou.pendingOrders || ou.orderHistory) {
          renderOrdersUI(ou.pendingOrders || [], ou.orderHistory || []);
        }
        break;
      }

      case 'orders_data': {
        const od = msg.payload;
        renderOrdersUI(od.pending || [], od.history || []);
        break;
      }

      case 'cancel_order_result': {
        const cr = msg.payload;
        if (cr.success) {
          showToast('Order cancelled', 'OK');
        } else {
          showToast(cr.message || 'Failed to cancel', 'ERROR');
        }
        setTimeout(hideToast, 1500);
        break;
      }

      case 'shop_purchased': {
        const sp = msg.payload;
        const item = sp.item;
        // Play purchase sound if configured
        if (item.sound) playSoundFile(item.sound, 1);
        // Execute the action on client side
        if (item.action === 'add_entry') {
          showToast(sp.buyerName + ' bought: ' + item.name, 'Shop');
          // Only host handles the action modal
          if (mp.isHost) {
            setTimeout(() => { hideToast(); handleAddEntry(item.wheelId); }, 800);
          } else {
            setTimeout(hideToast, 3000);
          }
        } else if (item.action === 'remove_entry') {
          showToast(sp.buyerName + ' bought: ' + item.name, 'Shop');
          if (mp.isHost) {
            setTimeout(() => { hideToast(); handleRemoveEntry(item.wheelId); }, 800);
          } else {
            setTimeout(hideToast, 3000);
          }
        }
        rebuildShopUI();
        break;
      }

      case 'spin_rejected': {
        spinBtn.disabled = false;
        showToast('Spin rejected', msg.payload.reason === 'already_spinning' ? 'Already spinning!' : 'Error');
        setTimeout(hideToast, 2000);
        break;
      }

      case 'error': {
        console.warn('[server]', msg.payload.message);
        break;
      }
    }
  }

  // ── Config lock for non-host ──
  function updateConfigLock() {
    const locked = mp.connected && !mp.isHost;
    textarea.readOnly = locked;
    textarea.style.opacity = locked ? '0.6' : '';

    // Hide configure + entries menu buttons entirely for non-host
    const configBtn = document.querySelector('.menu-btn[data-popup="configure"]');
    const entriesBtn = document.querySelector('.menu-btn[data-popup="entries"]');
    if (configBtn) configBtn.style.display = locked ? 'none' : '';
    if (entriesBtn) entriesBtn.style.display = locked ? 'none' : '';

    // Hide wheel selector entirely (non-host can't switch wheels)
    const wheelSelector = document.getElementById('wheelSelector');
    if (wheelSelector) wheelSelector.style.display = locked ? 'none' : '';

    // Hide entries editing controls
    document.querySelectorAll('.btn-shuffle, .btn-reset').forEach(b => b.style.display = locked ? 'none' : '');

    // If locked and a host-only popup is open, close it
    if (locked) {
      const configPopup = document.getElementById('popup-configure');
      const entriesPopup = document.getElementById('popup-entries');
      if ((configPopup && configPopup.classList.contains('show')) ||
          (entriesPopup && entriesPopup.classList.contains('show'))) {
        closePopup();
      }
    }

    // Show/hide shop edit toggle based on host status
    shopEditToggle.style.display = (mp.connected && mp.isHost) ? '' : 'none';
  }

  // ── Player list UI (Scoreboard in left panel) ──
  const scoreboardList = document.getElementById('scoreboardList');

  function updatePlayerListUI() {
    if (!scoreboardList) return;
    scoreboardList.innerHTML = '';
    const sorted = [...mp.players].sort((a, b) => (b.connected ? 1 : 0) - (a.connected ? 1 : 0) || b.points - a.points);
    sorted.forEach(p => {
      const row = document.createElement('div');
      row.className = 'sb-player' + (p.connected ? '' : ' disconnected');

      const avatar = document.createElement('div');
      avatar.className = 'sb-avatar';
      avatar.textContent = p.name.charAt(0).toUpperCase();
      if (p.color) avatar.style.background = p.color;
      row.appendChild(avatar);

      const nameEl = document.createElement('span');
      nameEl.className = 'sb-name';
      nameEl.textContent = p.name;
      row.appendChild(nameEl);

      if (p.isHost) {
        const badge = document.createElement('span');
        badge.className = 'sb-badge host';
        badge.textContent = 'HOST';
        row.appendChild(badge);
      }
      if (p.name === mp.playerName) {
        const badge = document.createElement('span');
        badge.className = 'sb-badge you';
        badge.textContent = 'YOU';
        row.appendChild(badge);
      }

      const money = document.createElement('span');
      money.className = 'sb-money';
      money.textContent = '$' + p.points;
      row.appendChild(money);

      scoreboardList.appendChild(row);
    });

    // Refresh boost panel max when player list updates
    refreshBoostPanel();
  }

  // ── Ready Bar + Betting ──
  const readyBar = document.getElementById('readyBar');
  const readyBarBtn = document.getElementById('readyBarBtn');
  const readyBarCountdown = document.getElementById('readyBarCountdown');
  const readyBarPlayers = document.getElementById('readyBarPlayers');
  const readyOverlay = document.getElementById('readyOverlay');
  const betEntrySelect = document.getElementById('betEntry');
  const betAmountInput = document.getElementById('betAmount');
  const betConfirmBtn = document.getElementById('betConfirmBtn');
  const betStatusEl = document.getElementById('betStatus');
  const betResultsEl = document.getElementById('betResults');

  let countdownInterval = null;
  let countdownEndTime = 0;
  let playerIsReady = false;
  let playerHasBet = false;
  let readyPhaseActive = false;
  let countdownSoundPlayed = false;
  let currentReadyWheelId = null;
  let readyNames = new Set();
  let allBets = []; // { playerName, color, entry, amount } synced from server
  let betHint = null;
  let spinChainResults = []; // accumulates { winner, wheelTitle } during sub-wheel chains

  function showReadyPhase(wheelId) {
    readyPhaseActive = true;
    playerIsReady = false;
    playerHasBet = false;
    currentReadyWheelId = wheelId;
    readyBarBtn.disabled = false;
    readyBarBtn.classList.remove('is-ready');
    readyBarBtn.textContent = 'READY';
    readyBarCountdown.textContent = '';
    readyNames = new Set();
    updateReadyBarChips();
  }

  function hideReadyPhase() {
    readyPhaseActive = false;
    countdownSoundPlayed = false;
    readyOverlay.classList.remove('show');
    readyBarCountdown.textContent = '';
    readyBarPlayers.innerHTML = '';
    readyBarBtn.disabled = false;
    readyBarBtn.classList.remove('is-ready');
    readyBarBtn.textContent = 'READY';
    playerIsReady = false;
    if (countdownInterval) { clearInterval(countdownInterval); countdownInterval = null; }
  }

  function updateReadyBarChips() {
    readyBarPlayers.innerHTML = '';
    mp.players.filter(p => p.connected).forEach(p => {
      const chip = document.createElement('span');
      chip.className = 'ready-bar-chip' + (readyNames.has(p.name) ? ' is-ready' : '');
      chip.textContent = p.name;
      readyBarPlayers.appendChild(chip);
    });
  }

  function startClientCountdown(seconds) {
    countdownEndTime = Date.now() + seconds * 1000;
    if (countdownInterval) clearInterval(countdownInterval);
    countdownInterval = setInterval(() => {
      const left = Math.max(0, Math.ceil((countdownEndTime - Date.now()) / 1000));
      readyBarCountdown.textContent = left > 0 ? left + 's' : '';
      if (left <= 0) {
        clearInterval(countdownInterval);
        countdownInterval = null;
      }
    }, 100);
  }

  // Ready bar button: starts ready phase (or marks ready if phase already active)
  readyBarBtn.addEventListener('click', () => {
    if (mainWheel.spinning || mainWheel.names.length < 2) return;
    if (!mp.connected) return;

    if (!readyPhaseActive) {
      // Start ready-up phase via spin request
      spinBtn.disabled = true;
      mp.send({ type: 'spin_request', payload: { wheelId: config.activeWheelId } });
    }

    if (!playerIsReady) {
      playerIsReady = true;
      readyBarBtn.classList.add('is-ready');
      readyBarBtn.textContent = 'READY!';
      readyBarBtn.disabled = true;
      mp.send({ type: 'ready' });
    }
  });

  function openBettingOverlay() {
    betStatusEl.textContent = '';
    betConfirmBtn.disabled = false;
    betAmountInput.value = '';

    // Populate bet entry dropdown
    betEntrySelect.innerHTML = '<option value="">Pick an entry...</option>';
    const wc = config.wheels[currentReadyWheelId || config.activeWheelId];
    if (wc) {
      const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
      entries.forEach(e => {
        const opt = document.createElement('option');
        opt.value = e; opt.textContent = e;
        betEntrySelect.appendChild(opt);
      });
    }

    const me = mp.players.find(p => p.name === mp.playerName);
    const balance = me ? me.points : 0;
    betAmountInput.max = balance;

    readyOverlay.classList.add('show');
  }

  // Close betting overlay button
  document.getElementById('closeBetOverlay').addEventListener('click', () => {
    readyOverlay.classList.remove('show');
  });

  betConfirmBtn.addEventListener('click', () => {
    const entry = betEntrySelect.value;
    const amount = parseInt(betAmountInput.value);
    if (!entry) { betStatusEl.textContent = 'Pick an entry to bet on'; return; }
    if (!amount || amount <= 0) { betStatusEl.textContent = 'Enter a bet amount'; return; }
    const me = mp.players.find(p => p.name === mp.playerName);
    if (me && amount > me.points) { betStatusEl.textContent = 'Not enough funds'; return; }

    mp.send({ type: 'bet', payload: { entry, amount } });
    betConfirmBtn.disabled = true;
    playerHasBet = true;
    betStatusEl.textContent = `Bet $${amount} on "${entry}"`;
  });

  function showBetResults(betResults) {
    betResultsEl.innerHTML = '';
    if (!betResults || betResults.length === 0) return;
    betResults.forEach(r => {
      const el = document.createElement('div');
      el.className = 'bet-result-item ' + (r.won ? 'won' : 'lost');
      if (r.won) {
        el.textContent = `${r.name} won $${r.payout}! (bet $${r.amount} on "${r.entry}")`;
      } else {
        el.textContent = `${r.name} lost $${r.amount} (bet on "${r.entry}")`;
      }
      betResultsEl.appendChild(el);
    });
    setTimeout(() => { betResultsEl.innerHTML = ''; }, 6000);
  }

  // ── Click-on-wheel betting ──
  function getSegmentFromClick(e) {
    const canvas = mainWheel.canvas;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const cx = canvas.width / 2, cy = canvas.height / 2;
    const mx = (e.clientX - rect.left) * scaleX - cx;
    const my = (e.clientY - rect.top) * scaleY - cy;
    const dist = Math.sqrt(mx * mx + my * my);
    const radius = cx * 0.92;
    if (dist > radius || dist < 20) return -1; // outside wheel or center
    // Angle relative to wheel rotation
    let angle = Math.atan2(my, mx) - mainWheel.rotation;
    angle = ((angle % TWO_PI) + TWO_PI) % TWO_PI;
    mainWheel.rebuildLayout();
    return segmentAtAngle(mainWheel.cachedSegments, angle);
  }

  // Bet via click / hold on wheel (accelerating)
  let betHoldTimer = null;
  let betHoldInterval = null;
  let betHoldButton = -1; // 0 = left, 2 = right
  let betHoldTicks = 0;

  function betAmountForTick(tick, ctrlKey) {
    // Accelerate: $1 for first 5 ticks, then $2, $5, $10, $25, $50...
    const base = ctrlKey ? 10 : 1;
    let mult = 1;
    if (tick > 20) mult = 50;
    else if (tick > 15) mult = 25;
    else if (tick > 10) mult = 10;
    else if (tick > 7) mult = 5;
    else if (tick > 4) mult = 2;
    return base * mult;
  }

  function placeBetAtAmount(e, button, amount) {
    if (!mp.connected || mainWheel.spinning) return;
    if (mainWheel.names.length < 2) return;
    const idx = getSegmentFromClick(e);
    if (idx < 0) return;
    const entry = mainWheel.names[idx];
    const isRemove = button === 2;
    const final = isRemove ? -amount : amount;
    mp.send({ type: 'bet', payload: { entry, entryIndex: idx, amount: final } });
    playSoundFile('chipsplaced.mp3', isRemove ? 0.3 : 0.5);
  }

  function stopBetHold() {
    if (betHoldTimer) { clearTimeout(betHoldTimer); betHoldTimer = null; }
    if (betHoldInterval) { clearInterval(betHoldInterval); betHoldInterval = null; }
    betHoldButton = -1;
    betHoldTicks = 0;
  }

  mainWheel.canvas.addEventListener('mousedown', (e) => {
    if (e.button !== 0 && e.button !== 2) return;
    betHoldButton = e.button;
    betHoldTicks = 0;
    // Place one bet immediately
    placeBetAtAmount(e, e.button, betAmountForTick(0, e.ctrlKey));
    // Start hold: after 400ms delay, repeat every 100ms with acceleration
    const held = e;
    betHoldTimer = setTimeout(() => {
      betHoldInterval = setInterval(() => {
        betHoldTicks++;
        placeBetAtAmount(held, betHoldButton, betAmountForTick(betHoldTicks, held.ctrlKey));
      }, 100);
    }, 400);
  });

  mainWheel.canvas.addEventListener('mouseup', stopBetHold);
  mainWheel.canvas.addEventListener('mouseleave', stopBetHold);

  // Prevent default context menu and handle right-click via mousedown
  mainWheel.canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
  });

  // Prevent click from also firing (mousedown already handles it)
  mainWheel.canvas.addEventListener('click', (e) => {
    e.stopPropagation();
  });

  // Bet tooltip on hover
  let betTooltip = null;
  mainWheel.canvas.addEventListener('mousemove', (e) => {
    if (!mp.connected || mainWheel.spinning || mainWheel.names.length < 2) {
      if (betTooltip) { betTooltip.remove(); betTooltip = null; }
      if (mainWheel.hoveredSegment !== -1) {
        mainWheel.hoveredSegment = -1;
        mainWheel.draw();
      }
      return;
    }
    const idx = getSegmentFromClick(e);
    if (idx < 0) {
      if (betTooltip) { betTooltip.remove(); betTooltip = null; }
      if (mainWheel.hoveredSegment !== -1) {
        mainWheel.hoveredSegment = -1;
        mainWheel.draw();
      }
      return;
    }
    // Play tick and highlight when hovering a new segment
    if (idx !== mainWheel.hoveredSegment) {
      mainWheel.hoveredSegment = idx;
      playTick(); // Same tick sound as wheel spinning
      mainWheel.draw();
    }
    const entry = mainWheel.names[idx];
    const betsOnEntry = allBets.filter(b => b.entryIndex === idx && b.amount > 0);
    // Build or update tooltip
    if (!betTooltip) {
      betTooltip = document.createElement('div');
      betTooltip.className = 'bet-tooltip';
      mainWheel.canvas.parentElement.appendChild(betTooltip);
    }
    const rect = mainWheel.canvas.parentElement.getBoundingClientRect();
    betTooltip.style.left = (e.clientX - rect.left) + 'px';
    betTooltip.style.top = (e.clientY - rect.top) + 'px';
    let html = '<div style="font-weight:700;margin-bottom:2px;">' + entry + '</div>';
    if (betsOnEntry.length > 0) {
      betsOnEntry.forEach(b => {
        html += '<div class="bet-tooltip-row"><span class="bet-tooltip-dot" style="background:' + b.color + '"></span>' + b.playerName + ': $' + b.amount + '</div>';
      });
    } else {
      html += '<div style="color:#888;">Click to bet</div>';
    }
    betTooltip.innerHTML = html;
  });

  mainWheel.canvas.addEventListener('mouseleave', () => {
    if (betTooltip) { betTooltip.remove(); betTooltip = null; }
    if (mainWheel.hoveredSegment !== -1) {
      mainWheel.hoveredSegment = -1;
      mainWheel.draw();
    }
  });

  // Betting hint
  betHint = document.createElement('div');
  betHint.className = 'wheel-bet-hint';
  betHint.textContent = 'Click to bet \u2022 Ctrl = $10 \u2022 Right-click to remove \u2022 Hold to repeat';
  betHint.style.display = 'none';
  mainWheel.canvas.parentElement.appendChild(betHint);

  // Draw bet chips on wheel after each draw
  const origDraw = mainWheel.draw;
  mainWheel.draw = () => {
    origDraw.call(mainWheel);
    if (allBets.length === 0 || mainWheel.names.length < 2) return;
    mainWheel.rebuildLayout();
    const segments = mainWheel.cachedSegments;
    const cw = mainWheel.canvas.width, cx = cw / 2;
    const r = cx * 0.92;
    const ctx = mainWheel.ctx;
    ctx.save();
    ctx.translate(cx, cx);
    ctx.rotate(mainWheel.rotation);

    // Group bets by entry index
    const betsByIndex = {};
    allBets.forEach(b => {
      if (b.amount <= 0) return;
      const key = b.entryIndex != null ? b.entryIndex : -1;
      if (!betsByIndex[key]) betsByIndex[key] = [];
      betsByIndex[key].push(b);
    });

    for (let i = 0; i < mainWheel.names.length; i++) {
      const bets = betsByIndex[i];
      if (!bets || bets.length === 0) continue;
      const seg = segments[i];
      const midAngle = seg.start + seg.arc / 2;
      const chipR = r * 0.45; // place chips ~45% out from center
      const chipCx = Math.cos(midAngle) * chipR;
      const chipCy = Math.sin(midAngle) * chipR;
      const chipSize = Math.max(8, Math.min(16, seg.arc * r * 0.12)) * devicePixelRatio;

      bets.forEach((b, bi) => {
        const offsetAngle = midAngle + (bi - (bets.length - 1) / 2) * chipSize * 2.5 / chipR;
        const bx = Math.cos(offsetAngle) * chipR;
        const by = Math.sin(offsetAngle) * chipR;

        // Chip circle
        ctx.beginPath();
        ctx.arc(bx, by, chipSize, 0, TWO_PI);
        ctx.fillStyle = b.color;
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 1.5 * devicePixelRatio;
        ctx.stroke();

        // Amount text
        ctx.save();
        ctx.fillStyle = '#fff';
        ctx.font = `700 ${chipSize * 0.9}px "Nunito",sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = 'rgba(0,0,0,0.5)';
        ctx.shadowBlur = 2;
        ctx.fillText('$' + b.amount, bx, by);
        ctx.restore();
      });
    }

    ctx.restore();
  };

  // ── Spin initiator overlay ──
  let initiatorTimer = null;
  function showInitiator(name) {
    spinInitiator.textContent = name + ' is spinning...';
    spinInitiator.classList.add('show');
    clearTimeout(initiatorTimer);
    initiatorTimer = setTimeout(() => spinInitiator.classList.remove('show'), 3000);
  }

  // ── Remote spin handler (deterministic replay) ──
  function handleRemoteSpin(payload) {
    const { initiator, wheelId, targetAngle, duration, minSpins, visitedChain } = payload;

    // Reset chain tracker at the start of a new spin sequence
    if (!visitedChain || visitedChain.length === 0) {
      spinChainResults = [];
    }

    // Server now sends personalized targetAngle for each client based on their local boosts
    // so we DON'T clear entry weights - keep the player's boosted view

    showInitiator(initiator);

    // Determine which wheel object to spin
    let wheel;
    const isMain = wheelId === config.activeWheelId;

    if (isMain) {
      clearSubWheels();
      resizeAllWheels();
      wheel = mainWheel;
    } else {
      // Sub-wheel: create cell if it doesn't exist yet
      const wc = config.wheels[wheelId];
      if (!wc) return;
      const entries = (wc.entries || '').split('\n').map(s => s.trim()).filter(Boolean);
      if (entries.length < 2) return;

      const { cell, wheel: sw } = createWheelCell(wc.title || wheelId);
      syncWheelConfig(sw, wc);
      sw.names = entries;
      sw.rotation = 0;
      sw.cooldowns.clear();
      sw.invalidateLayout();
      wheel = sw;

      // Let grid reflow
      setTimeout(() => { resizeAllWheels(); wheel.draw(); }, 50);
    }

    spinBtn.disabled = true;

    // Wait for sub-wheel to be ready before spinning
    const startSpin = () => {
      // Deterministic spin using server-provided parameters
      wheel.rebuildLayout();
      const segments = wheel.cachedSegments;
      if (!segments || segments.length === 0) return;

      // Find the winner from target angle
      const landAngle = targetAngle;

      // Calculate rotation to land pointer on target angle
      // Pointer is at top (3π/2 or -π/2) — the segment at pointer is the winner
      // We need: (-rotation - π/2) mod 2π == targetAngle
      // So: rotation = -π/2 - targetAngle (+ N*2π for min revolutions)
      let finalRot = -(Math.PI / 2) - landAngle;
      // Normalize to positive, then add full spins
      while (finalRot > wheel.rotation) finalRot -= TWO_PI;
      while (finalRot <= wheel.rotation + minSpins * TWO_PI) finalRot += TWO_PI;

      const startR = wheel.rotation;
      const delta = finalRot - startR;
      const startT = performance.now();
      const easePow = 5;
      let lastSeg = -1;
      wheel.spinning = true;

      // Track spin timing for hotbar boost item
      spinStartTime = startT;
      spinDurationMs = duration;
      spinEndTime = startT + duration;
      activeBoostOffset = 0;
      boostTarget = 0;
      if (isMain) { rebuildHotbar(); startHotbarRefresh(); }

      let lastAnimTime = startT;
      function animate(now) {
        const dt = (now - lastAnimTime) / 1000; // seconds since last frame
        lastAnimTime = now;
        // Smoothly interpolate boost offset toward target (~3x per second lerp)
        if (Math.abs(boostTarget - activeBoostOffset) > 0.001) {
          activeBoostOffset += (boostTarget - activeBoostOffset) * Math.min(1, dt * 3);
        } else {
          activeBoostOffset = boostTarget;
        }
        // Use spinDurationMs which can be extended by boosts
        const t = Math.min((now - spinStartTime) / spinDurationMs, 1);
        wheel.rotation = startR + delta * (1 - Math.pow(1 - t, easePow)) + activeBoostOffset;

        // Tick sound
        const pointerAngle = (((-wheel.rotation - Math.PI / 2) % TWO_PI) + TWO_PI) % TWO_PI;
        const curSeg = segmentAtAngle(segments, pointerAngle);
        if (curSeg !== lastSeg && lastSeg !== -1) {
          playTick();
          if (wheel.pointerEl) {
            wheel.pointerEl.classList.add('tick');
            setTimeout(() => wheel.pointerEl.classList.remove('tick'), 50);
          }
        }
        lastSeg = curSeg;
        wheel.draw();

        if (t < 1) {
          wheel.animFrame = requestAnimationFrame(animate);
        } else {
          wheel.spinning = false;
          // Determine winner (including any boost offset)
          const finalPointer = (((-wheel.rotation - Math.PI / 2) % TWO_PI) + TWO_PI) % TWO_PI;
          const winIdx = segmentAtAngle(segments, finalPointer);
          const winner = wheel.names[winIdx];

          if (isMain) rebuildHotbar();

          // Report to server (only first report matters)
          mp.send({ type: 'spin_complete', payload: { wheelId, winner } });
        }
      }
      wheel.animFrame = requestAnimationFrame(animate);
    };

    if (isMain) {
      startSpin();
    } else {
      // Delay for sub-wheel to render
      setTimeout(startSpin, 400);
    }
  }

  // ── Handle spin finished (server-confirmed winner + next action) ──
  function handleSpinFinished(payload) {
    const { wheelId, winner, nextAction } = payload;
    spinBtn.disabled = false;
    rebuildHotbar();
    refreshBoostPanel();

    // Boosts are reverted by server (boost_reverted messages) so no need to restore weights

    const isMain = wheelId === config.activeWheelId;
    const wheelTitle = isMain ? (config.wheels[wheelId]?.title || 'Main Wheel') : (config.wheels[wheelId]?.title || 'Sub-Wheel');

    if (!nextAction) {
      // Terminal win — show full chain if we accumulated results
      spinChainResults.push({ winner, wheelTitle });
      if (spinChainResults.length > 1) {
        showChainWinner(spinChainResults);
      } else {
        showWinner(winner, isMain ? 'Winner' : wheelTitle);
      }
      spinChainResults = [];
      playWinSound(winner, wheelId);
      if (isMain && !mp.connected) {
        advanceCD(winner);
        applyCD(winner);
        mainWheel.invalidateLayout();
      }
      return;
    }

    // Accumulate this result into the chain
    spinChainResults.push({ winner, wheelTitle });

    switch (nextAction.type) {
      case '__add_entry':
        playWinSound(winner, wheelId);
        showToast(winner, 'Add Entry!');
        startConfetti();
        setTimeout(() => {
          hideToast(); stopConfetti();
          if (mp.isHost) handleAddEntry(wheelId);
        }, 1200);
        break;

      case '__remove_entry':
        playWinSound(winner, wheelId);
        showToast(winner, 'Remove Entry!');
        startConfetti();
        setTimeout(() => {
          hideToast(); stopConfetti();
          if (mp.isHost) handleRemoveEntry(wheelId);
        }, 1200);
        break;

      case '__spin_again':
        playWinSound(winner, wheelId);
        showToast(winner, 'Spin Again!');
        startConfetti();
        setTimeout(() => { hideToast(); stopConfetti(); }, 1500);
        break;

      case 'subwheel':
        showToast(winner, isMain ? 'Winner' : wheelTitle);
        startConfetti();
        playWinSound(winner, wheelId);
        setTimeout(() => { hideToast(); stopConfetti(); }, 1800);
        break;
    }

    if (isMain && !mp.connected) {
      advanceCD(winner);
      applyCD(winner);
      mainWheel.invalidateLayout();
    }
  }

  function showChainWinner(chain) {
    // Build HTML showing each step in the chain
    const stepsHtml = chain.map((step, i) => {
      const isLast = i === chain.length - 1;
      const label = step.wheelTitle;
      const nameStyle = isLast
        ? 'font-size:1.8rem;font-weight:800;background:linear-gradient(135deg,#e94560,#f5a623);-webkit-background-clip:text;-webkit-text-fill-color:transparent;'
        : 'font-size:1.1rem;font-weight:600;color:var(--text);';
      const labelStyle = 'font-size:0.7rem;text-transform:uppercase;letter-spacing:1.5px;color:var(--text-muted);margin-bottom:2px;';
      return '<div style="margin-bottom:' + (isLast ? '0' : '8px') + ';">'
        + '<div style="' + labelStyle + '">' + label + '</div>'
        + '<div style="' + nameStyle + '">' + step.winner + '</div>'
        + (isLast ? '' : '<div style="color:var(--text-muted);font-size:0.9rem;margin-top:4px;">&#x25BC;</div>')
        + '</div>';
    }).join('');

    winnerLabelEl.textContent = '';
    winnerEl.innerHTML = stepsHtml;
    modal.classList.add('show');
    modalCb = null;
    startConfetti();
  }

  // ── Multiplayer-aware main spin ──
  function doMainSpinMP() {
    if (mainWheel.spinning || mainWheel.names.length < 2) return;
    if (!mp.connected) {
      doMainSpin();
      return;
    }
    // Trigger the ready bar button click (starts phase + marks ready + opens betting)
    readyBarBtn.click();
  }

  // ── Events ──
  textarea.addEventListener('input', updateNames);
  spinBtn.addEventListener('click', doMainSpinMP);
  window.addEventListener('resize', resizeAllWheels);

  // ── Init ──
  loadConfig();
  rebuildWheelSelector();
  const initWc = selectedWheelConfig();
  if (initWc) syncWheelConfig(mainWheel, initWc);
  textarea.value = initWc ? initWc.entries || '' : DEFAULT_ENTRIES;
  updateNames();
  mainWheel.resizeCanvas();
})();
</script>
</body>
</html>
